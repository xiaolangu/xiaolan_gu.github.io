<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-30T01:00:18-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Xiaolan Gu</title><subtitle>Ph.D. student, ECE Department, University of Arizona</subtitle><author><name>Xiaolan Gu</name><email>xiaolang@email.arizona.edu</email></author><entry><title type="html">Notes for Computer Networks</title><link href="http://localhost:4000/posts/2017/07/computer-networks/" rel="alternate" type="text/html" title="Notes for Computer Networks" /><published>2017-07-05T00:00:00-07:00</published><updated>2017-07-05T00:00:00-07:00</updated><id>http://localhost:4000/posts/2017/07/computer-networks</id><content type="html" xml:base="http://localhost:4000/posts/2017/07/computer-networks/">&lt;h1 id=&quot;chapter-1&quot;&gt;Chapter 1&lt;/h1&gt;

&lt;h1 id=&quot;multiplexing&quot;&gt;Multiplexing&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;FDM: the frequency spectrum is divided into frequency bands for individual signals.
    &lt;ul&gt;
      &lt;li&gt;Wavelength Division Multiplexing is just FDM at very high frequencies&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TDM: the users take turns to use the entire bandwidth for a little burst of time.&lt;/li&gt;
  &lt;li&gt;CDMA (Code Division Multiple Access)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;switching&quot;&gt;Switching&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;circuit switching
    &lt;ul&gt;
      &lt;li&gt;connection-oriented&lt;/li&gt;
      &lt;li&gt;a complete path established prior to the call, which lasts for the duration&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;message switching&lt;/li&gt;
  &lt;li&gt;packet switching
    &lt;ul&gt;
      &lt;li&gt;connection-less&lt;/li&gt;
      &lt;li&gt;data is divided into packets&lt;/li&gt;
      &lt;li&gt;users share network resources (link, router) with store-and-forward approach.&lt;/li&gt;
      &lt;li&gt;route chosen on packet-by-packet basis&lt;/li&gt;
      &lt;li&gt;statistical multiplexing: resource are allocated and shared on demand.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Virtual circuit:
    &lt;ul&gt;
      &lt;li&gt;All packets associated with a session follow the same path&lt;/li&gt;
      &lt;li&gt;Route is chosen at start of session&lt;/li&gt;
      &lt;li&gt;Packets are labeled with a VC# designating the route&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;four-sources-of-packet-delay&quot;&gt;Four sources of packet delay&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;processing&lt;/li&gt;
  &lt;li&gt;queuing&lt;/li&gt;
  &lt;li&gt;transmission delay&lt;/li&gt;
  &lt;li&gt;propagation delay&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;the-network-core&quot;&gt;The network core&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;mesh of interconnected routers&lt;/li&gt;
  &lt;li&gt;how is data transferred through net?
    &lt;ul&gt;
      &lt;li&gt;circuit switching&lt;/li&gt;
      &lt;li&gt;packet switching&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;network-of-networks&quot;&gt;Network of Networks&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ISP: Internet Service Provider&lt;/li&gt;
  &lt;li&gt;Tier-1 ISP
    &lt;ul&gt;
      &lt;li&gt;can reach every other network on the Internet without purchasing IP transit or paying settlements&lt;/li&gt;
      &lt;li&gt;treat each other as equals&lt;/li&gt;
      &lt;li&gt;national/international coverage (e.g. ChinaGBN, ChinaNet)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tier-2 ISP
    &lt;ul&gt;
      &lt;li&gt;smaller (often) regional ISPs, connect to one or more Tier-1 ISPs, possibly other Tier-2 ISPs&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tier-3 ISP
    &lt;ul&gt;
      &lt;li&gt;last hop (“access”) network (closest to end systems)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-2&quot;&gt;Chapter 2&lt;/h1&gt;
&lt;h1 id=&quot;hybrid-of-client-server-and-p2p&quot;&gt;Hybrid of client-server and P2P&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Skype
    &lt;ul&gt;
      &lt;li&gt;voice-over-IP P2P application&lt;/li&gt;
      &lt;li&gt;centralized server: finding address of remote party&lt;/li&gt;
      &lt;li&gt;client-client connection: direct (not through server)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Instant messaging
    &lt;ul&gt;
      &lt;li&gt;chatting between two users is P2P&lt;/li&gt;
      &lt;li&gt;centralized service: client presence detection/location&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;what-transport-services-dies-an-app-need&quot;&gt;What transport services dies an app need?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;data loss&lt;/li&gt;
  &lt;li&gt;delay&lt;/li&gt;
  &lt;li&gt;throughput: some apps (e.g., multimedia) require minimum amount of throughput to be “effective”; other apps (“elastic apps”) make use of whatever throughput they get.&lt;/li&gt;
  &lt;li&gt;security
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/transport-service.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;tcp-service&quot;&gt;TCP service&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;connection-oriented&lt;/li&gt;
  &lt;li&gt;reliable transport&lt;/li&gt;
  &lt;li&gt;flow control: sender won’t overwhelm receiver&lt;/li&gt;
  &lt;li&gt;congestion control: throttle sender when network overloaded&lt;/li&gt;
  &lt;li&gt;does not provide: timing, minimum throughput guarantees, security&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;identifying-processes&quot;&gt;Identifying processes&lt;/h1&gt;
&lt;p&gt;process identifier = IP address + port numbers&lt;/p&gt;

&lt;h1 id=&quot;domain-name-system&quot;&gt;Domain Name System&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;map between IP addresses and name.
    &lt;ul&gt;
      &lt;li&gt;www.sjtu.edu.cn –&amp;gt; 202.120.2.119&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;distributed database&lt;/strong&gt; implemented in hierarchy of many &lt;strong&gt;name servers&lt;/strong&gt;
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/hierarchical.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;TLDs (Top-Level Domains)
        &lt;ul&gt;
          &lt;li&gt;22+ generic TLDs&lt;/li&gt;
          &lt;li&gt;about 250 country code TLDs&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;application-layer protocol&lt;/strong&gt; host, routers, name servers to communicate to resolve names (address/name translation)&lt;/li&gt;
  &lt;li&gt;UDP on port 53&lt;/li&gt;
  &lt;li&gt;13 root name services worldwide
    &lt;ul&gt;
      &lt;li&gt;Contacted by local name server that can not resolve name
        &lt;ul&gt;
          &lt;li&gt;contacts authoritative name server if name mapping not known&lt;/li&gt;
          &lt;li&gt;gets mapping&lt;/li&gt;
          &lt;li&gt;returns mapping to local name server&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;When host makes DNS query, query is sent to its local DNS server
    &lt;ul&gt;
      &lt;li&gt;acts as proxy, forwards query into hierarchy&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;dns-protocol-messages&quot;&gt;DNS protocol, messages&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;DNS protocol: query and reply messages, both with same message format&lt;/li&gt;
  &lt;li&gt;identification: 16 bit # for query, reply to query uses same #
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/dns.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;dns-servers&quot;&gt;DNS servers&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Three classes:
    &lt;ul&gt;
      &lt;li&gt;root DNS servers&lt;/li&gt;
      &lt;li&gt;top-level domain DNS servers: These servers are responsible for top-level domains such as com, org, net, edu, and gov, and all of the country top-level domains such as uk, fr, ca, and jp.&lt;/li&gt;
      &lt;li&gt;authoritative DNS servers&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;There is another important type of DNS server called the local DNS server. A local DNS server does not strictly belong to the hierarchy of servers but is nevertheless central to the DNS architecture&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;httphypertext-transfer-protocol&quot;&gt;HTTP（HyperText Transfer Protocol）&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Uses TCP
    &lt;ul&gt;
      &lt;li&gt;client initiates TCP connection (creates socket) to server, port 80&lt;/li&gt;
      &lt;li&gt;server accepts TCP connection from client&lt;/li&gt;
      &lt;li&gt;HTTP messages exchanged between browser (HTTP client) and Web server (HTTP server)&lt;/li&gt;
      &lt;li&gt;TCP connection closed&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP is “stateless”
    &lt;ul&gt;
      &lt;li&gt;server maintains no information about past client requests&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;http request message general format
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/http-request.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;method types
    &lt;ul&gt;
      &lt;li&gt;HTTP/1.0
        &lt;ul&gt;
          &lt;li&gt;GET&lt;/li&gt;
          &lt;li&gt;POST&lt;/li&gt;
          &lt;li&gt;HEAD&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HTTP/1.1
        &lt;ul&gt;
          &lt;li&gt;GET, POST, HEAD&lt;/li&gt;
          &lt;li&gt;PUT&lt;/li&gt;
          &lt;li&gt;DELETE&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;http-response-status-codes&quot;&gt;HTTP response status codes&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Every request gets a response consisting of a status line, and possibly additional information.&lt;/li&gt;
  &lt;li&gt;The status line contains a three-digit status code telling whether the request was satisfied, and if not, why not.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;cookies&quot;&gt;Cookies&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;four components:
    &lt;ul&gt;
      &lt;li&gt;cookie header line of HTTP response message&lt;/li&gt;
      &lt;li&gt;cookie header line in HTTP request message&lt;/li&gt;
      &lt;li&gt;cookie file kept on user’s host, managed by user’s browser&lt;/li&gt;
      &lt;li&gt;back-end database at Web site&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;http-performance&quot;&gt;HTTP Performance&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Round Trip Time (RTT): time for a small packet to travel from client to server and back&lt;/li&gt;
  &lt;li&gt;Page Load Time (PLT):
    &lt;ul&gt;
      &lt;li&gt;One RTT to initiate TCP connection&lt;/li&gt;
      &lt;li&gt;one RTT for HTTP request and first few bytes of HTTP response to return&lt;/li&gt;
      &lt;li&gt;file transmission time&lt;/li&gt;
      &lt;li&gt;total = 2 * RTT + transmission time&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;electronic-mail&quot;&gt;Electronic Mail&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;mail servers
    &lt;ul&gt;
      &lt;li&gt;mailbox: contains incoming messages for users&lt;/li&gt;
      &lt;li&gt;message queue: contains outgoing messages to be sent&lt;/li&gt;
      &lt;li&gt;SMTP protocol: between mail servers to send emails messages
        &lt;ul&gt;
          &lt;li&gt;duplex TCP connection at port 25&lt;/li&gt;
          &lt;li&gt;client: sending mail server&lt;/li&gt;
          &lt;li&gt;server: receiving mail server&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;mail access protocol
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/mail-access.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;POP:
        &lt;ul&gt;
          &lt;li&gt;download and delete&lt;/li&gt;
          &lt;li&gt;stateless across sessions&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;IMAP:
        &lt;ul&gt;
          &lt;li&gt;keep all messages at server&lt;/li&gt;
          &lt;li&gt;keeps user state across sessions&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;http: gmail etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;cdn-content-delivery-network&quot;&gt;CDN: Content delivery network&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Replicate Web pages on a bunch of servers&lt;/li&gt;
  &lt;li&gt;Efficient distribution of popular content&lt;/li&gt;
  &lt;li&gt;Faster delivery for clients&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;mime&quot;&gt;MIME&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Multipurpose Internet Mail Extensions&lt;/li&gt;
  &lt;li&gt;MIME: to continue to use the RFC 822 format, but to add structure to the message body and define encoding rules for non-ASCII messages.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;p2p&quot;&gt;P2P&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Distributed Hash Table
    &lt;ul&gt;
      &lt;li&gt;The distributed index Database has (key, value) pairs;
        &lt;ul&gt;
          &lt;li&gt;key: content keywords&lt;/li&gt;
          &lt;li&gt;value: IP address of the hosts with the content&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Assign integer identifier to each peer:
        &lt;ul&gt;
          &lt;li&gt;ID(peer) = hash(IP, port)&lt;/li&gt;
          &lt;li&gt;each peer only aware of immediate successor clockwise&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;How to store (key, value) pairs in peers?
        &lt;ul&gt;
          &lt;li&gt;Rule: store (key, value) pair to the peer that has the closestID.&lt;/li&gt;
          &lt;li&gt;Convention: closest is the immediate successor of the key.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;distributed-hash-table&quot;&gt;Distributed Hash Table&lt;/h1&gt;
&lt;p&gt;both the number of neighbors per peer as well as the number of messages per query is O(log N), where N is the number of peers.
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/finger-table.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;socket&quot;&gt;Socket&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Socket is locally identified with a port number&lt;/li&gt;
  &lt;li&gt;Client needs to know server IP address and socket port number.&lt;/li&gt;
  &lt;li&gt;API:
    &lt;ul&gt;
      &lt;li&gt;BIND: associate a local address (port) with a asocket&lt;/li&gt;
      &lt;li&gt;LISTEN: announce willingness to accept connections&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-3&quot;&gt;Chapter 3&lt;/h1&gt;

&lt;h1 id=&quot;tcp-and-udp&quot;&gt;TCP and UDP&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/tcp-udp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TCP
    &lt;ul&gt;
      &lt;li&gt;Flow control matches sender to receiver&lt;/li&gt;
      &lt;li&gt;Congestion control matches sender to network
        &lt;h1 id=&quot;ports&quot;&gt;Ports&lt;/h1&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Servers often bind to “well-known ports”&lt;/li&gt;
  &lt;li&gt;FTP (20/21), SMTP (25), POP3 (110), IMAP (143), http (80), https(443).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;connection-oriented-demux-threaded-web-server&quot;&gt;Connection-oriented demux: Threaded Web Server&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;TCP socket identified by 4-tuple:&lt;br /&gt;
(source IP address, source port number, dest IP address, dest port number)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;connectionless-demux&quot;&gt;Connectionless demux&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;UDP socket identified by two-tuple:&lt;br /&gt;
(dest IP address, dest port number)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;why-udp&quot;&gt;Why UDP?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;no connection establishment (which can add delay)&lt;/li&gt;
  &lt;li&gt;no retransmission (which can add delay)&lt;/li&gt;
  &lt;li&gt;simple: no connection state at sender, receiver&lt;/li&gt;
  &lt;li&gt;small segment header: 8 bytes&lt;/li&gt;
  &lt;li&gt;no flow control and congestion control: UDP can blast away as fast as desired&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Examples&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;short message interaction apps: DNS, SNMP, PRC&lt;/li&gt;
      &lt;li&gt;loss tolerant and delay sensitive: ipPhone, SKYPE&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;error-detection-code-edc-and-retransmission&quot;&gt;Error detection code (EDC) and retransmission&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Parity checking
    &lt;ul&gt;
      &lt;li&gt;single bit parity&lt;/li&gt;
      &lt;li&gt;two dimensional bit parity&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Checksum: used in Internet (IP, TCP, UDP), but it is weak&lt;/li&gt;
  &lt;li&gt;CRC: cyclic redundancy check
    &lt;ul&gt;
      &lt;li&gt;Cyclic Redundancy Check used in link layer can detect all burst errors less than r+1 bits&lt;/li&gt;
      &lt;li&gt;Four International Standards Generator Polynomials
  &lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/crc.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;The power of CRC:
        &lt;ul&gt;
          &lt;li&gt;all single-bit errors will be detected&lt;/li&gt;
          &lt;li&gt;All two isolated single-bit errors will be detected&lt;/li&gt;
          &lt;li&gt;By making (x + 1) a factor of G(x), all errors consisting of an odd number of inverted bits will be detected&lt;/li&gt;
          &lt;li&gt;all burst errors of length &amp;lt;= r will be detected&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;can be constructed in hardware&lt;/li&gt;
      &lt;li&gt;CRCs are widely used on links (Ethernet, ADSL, Cable)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;forwarding-error-correction&quot;&gt;Forwarding Error Correction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Hamming Code
    &lt;ul&gt;
      &lt;li&gt;can only correct one bit error&lt;/li&gt;
      &lt;li&gt;used when the error rate is low&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Convolutional codes and LDPC heavily used in wireless data link layer&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;detection-vs-correction&quot;&gt;Detection vs Correction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Forward Error Correction:
    &lt;ul&gt;
      &lt;li&gt;when errors are expected&lt;/li&gt;
      &lt;li&gt;or when no time for transmission&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Error Detection and Retransmission
    &lt;ul&gt;
      &lt;li&gt;more efficient when errors are not expected&lt;/li&gt;
      &lt;li&gt;burst errors when they do occur&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;reliable-data-transfer&quot;&gt;Reliable Data Transfer&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;RDT 1.0:
    &lt;ul&gt;
      &lt;li&gt;underlying channel perfectly reliable (no error control)&lt;/li&gt;
      &lt;li&gt;receiver has enough buffer and CPU power (no flow control)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RDT 2.0: channel with errors
    &lt;ul&gt;
      &lt;li&gt;underlying channel may flip bits in packet (no lost)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;checksum&lt;/strong&gt; to detect bit errors&lt;/li&gt;
      &lt;li&gt;receiver feedback: control msgs (ACK, NAK)&lt;/li&gt;
      &lt;li&gt;sender retransmits pkt on receipt of NAK&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;FLAWS&lt;/strong&gt;:
        &lt;ul&gt;
          &lt;li&gt;if ACK/NAK corrupted, sender doesn’t know what happened at receiver&lt;/li&gt;
          &lt;li&gt;possible duplicate pkt with retransmission&lt;/li&gt;
          &lt;li&gt;Handling duplicates:
            &lt;ul&gt;
              &lt;li&gt;sender retransmits current pkt if ACK/NAK garbled&lt;/li&gt;
              &lt;li&gt;sender adds &lt;strong&gt;sequence number&lt;/strong&gt; to each pkt&lt;/li&gt;
              &lt;li&gt;receiver discards duplicate pkt&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RDT 2.1： receiver handles garbled ACK/NAKs&lt;/li&gt;
  &lt;li&gt;RDT 2.2: a NAK-free protocol
    &lt;ul&gt;
      &lt;li&gt;instead of NAK, receiver sends ACK for last pkt received OK, receiver must explicitlyinclude seq # of pkt being ACKed&lt;/li&gt;
      &lt;li&gt;duplicate ACK at sender results in same action as NAK: retransmit current pkt&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RDT 3.0: channels with errors and loss
    &lt;ul&gt;
      &lt;li&gt;sender waits “reasonable” amount of time for ACK&lt;/li&gt;
      &lt;li&gt;requires countdown timer&lt;/li&gt;
      &lt;li&gt;to handle duplicate pkt, receiver must specify seq # of pkt being ACKed&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;selective-repeat-vs-go-back-n&quot;&gt;Selective Repeat vs Go-Back-N&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Go-back-N: timer for oldest in-flight pkt
    &lt;ul&gt;
      &lt;li&gt;cumulative ACK&lt;/li&gt;
      &lt;li&gt;retransmit pkt k and all higher seq# pkts in window when timeout(k)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Selective Repeat
    &lt;ul&gt;
      &lt;li&gt;individual ACK&lt;/li&gt;
      &lt;li&gt;sender timer for each unACKed pkt&lt;/li&gt;
      &lt;li&gt;sender only resends pkts for which ACK not received&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;window-overlay-problem&quot;&gt;Window Overlay Problem&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/window-overlay.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;To avoid overlapping new receiving window with the original window, the maximum window size should satisfy:&lt;br /&gt; 
&lt;strong&gt;sending window + receiving window &amp;lt;= (MAX_SEQ + 1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-overview&quot;&gt;TCP overview&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;end-to-end: no support for multicasting or broadcasting&lt;/li&gt;
  &lt;li&gt;reliable byte stream:
    &lt;ul&gt;
      &lt;li&gt;no “message boundaries”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;hybrid of GBN and SR
    &lt;ul&gt;
      &lt;li&gt;pipelined segments&lt;/li&gt;
      &lt;li&gt;cumulative and piggyback acks&lt;/li&gt;
      &lt;li&gt;single retransmission timer&lt;/li&gt;
      &lt;li&gt;retransmissions are triggered by
        &lt;ul&gt;
          &lt;li&gt;timeout events&lt;/li&gt;
          &lt;li&gt;3 duplicate acks before timer expires: &lt;strong&gt;fast retransmit&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;only retransmit one segment&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;full duplex&lt;/li&gt;
  &lt;li&gt;sequence number: byte stream “number” of first byte in segment’s data&lt;/li&gt;
  &lt;li&gt;TCP checksum:
    &lt;ul&gt;
      &lt;li&gt;TCP checksum checks the header, the data, and a pseudo header.&lt;/li&gt;
      &lt;li&gt;The pseudo-header helps detect mis-delivered packets.&lt;/li&gt;
      &lt;li&gt;It also violates the protocol hierarchy since the IP addresses in it belong to the IP layer, not to the TCP layer.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-timer-management&quot;&gt;TCP timer management&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Problem: How do we determine the best timeout value for retransmitting segments in the face of a large standard deviation of round-trip delays?&lt;/li&gt;
  &lt;li&gt;Solution: uses &lt;strong&gt;dynamic algorithm&lt;/strong&gt; that constantly adjusts the timeout interval, based on continuous measurements of network performance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-flow-control&quot;&gt;TCP flow control&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;announcing window size:the maximum number of bytes that may be sent and received.&lt;/li&gt;
  &lt;li&gt;zero window size: sender stop sending. Two exceptions:
    &lt;ul&gt;
      &lt;li&gt;urgent data&lt;/li&gt;
      &lt;li&gt;1-byte request for reannounce the window size.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-congestion-control&quot;&gt;TCP congestion control&lt;/h2&gt;
&lt;p&gt;Congestion can be caused by:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;data in burst (app and transport layer)&lt;/li&gt;
  &lt;li&gt;lack of capacity/bandwidth (physical layer)&lt;/li&gt;
  &lt;li&gt;insufficient memory of routers (network layer)&lt;/li&gt;
  &lt;li&gt;slow processors of routers (network layer)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;congestion-prevention-policies-in-open-loop-systems&quot;&gt;Congestion Prevention Policies in Open Loop Systems&lt;/h2&gt;
&lt;p&gt;To achieve congestion control, select appropriate policies at various levels: data link, network, and transport layer.
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/congestion-policy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;strategy:
    &lt;ul&gt;
      &lt;li&gt;predict when congestion is about to happen&lt;/li&gt;
      &lt;li&gt;reduce rate early&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;two approaches:
    &lt;ul&gt;
      &lt;li&gt;host-centric: TCP congestion control&lt;/li&gt;
      &lt;li&gt;Router-centric: warning bit, choke packet, load shedding&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-congestion-control-1&quot;&gt;TCP congestion control&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Sender uses &lt;strong&gt;packet loss&lt;/strong&gt; as the network congestion signal
    &lt;ul&gt;
      &lt;li&gt;TCP assume that lost packets are caused by congestion, not by links.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TCP use a Congestion Window (CongWin)next to the window granted by the receiver. The actual window size is the minimum of the two.&lt;/li&gt;
  &lt;li&gt;Algorithm:
    &lt;ul&gt;
      &lt;li&gt;When CongWin is below Threshold, sender in slow-start phase, window grows exponentially.&lt;/li&gt;
      &lt;li&gt;When CongWin is above Threshold, sender is in congestion-avoidance phase, window grows linearly.&lt;/li&gt;
      &lt;li&gt;When a triple duplicate ACK occurs, Threshold and CongWin set to CongWin/2.&lt;/li&gt;
      &lt;li&gt;When timeout occurs, Threshold set to CongWin/2 and CongWin is set to 1 MSS.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-additive-increase-multiplicative-decrease-aimd&quot;&gt;TCP Additive Increase, Multiplicative Decrease (AIMD)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;additive increase&lt;/strong&gt;: increase CongWin by 1 MSS every RTT until loss detected&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;multiplicative decrease&lt;/strong&gt;: cut CongWin in half after loss&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;when-should-the-slow-start-exponential-increase-end&quot;&gt;When should the slow start (exponential increase) end?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;If there is a loss event:
    &lt;ul&gt;
      &lt;li&gt;sets the value of congestion window to 1&lt;/li&gt;
      &lt;li&gt;sets the “slow start threshold” to cwnd/2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;when the value of cwnd equals ssthresh, slow start ends and TCP transitions into congestion avoidance mode.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;when-should-congestion-avoidances-linear-increase-of-1-mss-per-rtt-end&quot;&gt;when should congestion avoidance’s linear increase (of 1 MSS per RTT) end?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;a timeout occurs
    &lt;ul&gt;
      &lt;li&gt;The value of cwnd is set to 1 MSS, and the value of ssthresh is updated to half the value of cwnd&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;a triple duplicate ACK event
    &lt;ul&gt;
      &lt;li&gt;TCP halves the value of cwnd&lt;/li&gt;
      &lt;li&gt;the value of ssthresh to be half the value of cwnd&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-throughput&quot;&gt;TCP throughput&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Under assumptions, Because TCP’s throughput (that is, rate) increases linearly between the two extreme values, we have:&lt;br /&gt;
average throughput = 0.75 * W / RTT&lt;/li&gt;
  &lt;li&gt;the throughput of a TCP connection as a function of the loss rate (L), the round-trip time (RTT), and the maximum segment size (MSS):&lt;br /&gt;
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/tcp-throughput.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-fairness&quot;&gt;TCP fairness&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;A congestion-control mechanism is said to be fair if the average transmission rate of each connection is approximately R/K; that is, each connection gets an equal share of the link bandwidth.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-4&quot;&gt;Chapter 4&lt;/h1&gt;
&lt;h2 id=&quot;network-layer-function&quot;&gt;Network Layer Function:&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;glue/interconnect&lt;/strong&gt; lower-level networks together: allow packets to be sent between any pair of hosts&lt;/li&gt;
  &lt;li&gt;network layer provides either host-to-host connectionless service or host-to-host connection service, &lt;strong&gt;but not both.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;connection service =&amp;gt; virtual circuit (VC) networks&lt;/li&gt;
  &lt;li&gt;connectionless service =&amp;gt; datagram networks&lt;/li&gt;
  &lt;li&gt;network-layer connection service is &lt;strong&gt;implemented in the routers in the network core as well as in the end systems&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Internet is a datagram network.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;router-functions&quot;&gt;Router Functions:&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;routing&lt;/li&gt;
  &lt;li&gt;forwarding/switching&lt;/li&gt;
  &lt;li&gt;congestion control: drop packets, update routing table&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Router Forwarding Plane are typically implemented in &lt;strong&gt;hardware&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;ROuter Control Plane are typically implemented in &lt;strong&gt;software&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;virtual-circuit&quot;&gt;Virtual Circuit&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;VC consists of:
    &lt;ul&gt;
      &lt;li&gt;path from source to destination&lt;/li&gt;
      &lt;li&gt;VC numbers, one number for each link along the path&lt;/li&gt;
      &lt;li&gt;entries in routers along path&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Packet carries VC number rather than destination address as the index of forwarding&lt;/li&gt;
  &lt;li&gt;VC number can be changed on each link&lt;/li&gt;
  &lt;li&gt;Routers maintain connection state information&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;why-not-keep-the-same-vc-number&quot;&gt;Why not keep the same VC number?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;replacing the number from link to link reduces the length of the VC field in the packet header.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VC setup is considerably simplified&lt;/strong&gt; by permitting a different VC number at each link along the path of the VC&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;router-four-parts&quot;&gt;Router (four parts)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;input port&lt;/li&gt;
  &lt;li&gt;output port&lt;/li&gt;
  &lt;li&gt;routing processor&lt;/li&gt;
  &lt;li&gt;switching fabric&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;input-port-function&quot;&gt;Input port function&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;physical layer
    &lt;ul&gt;
      &lt;li&gt;bit-level reception&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;data link layer
    &lt;ul&gt;
      &lt;li&gt;processing (protocol, decapsulation)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;network layer
    &lt;ul&gt;
      &lt;li&gt;lookup, forwarding, queuing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;three-types-of-switching&quot;&gt;Three types of switching&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;memory: The simplest, earliest routers were traditional computers,
with switching between input and output ports being done under direct control of the CPU (routing processor). An input port with an arriving packet first signaled the routing processor via an interrupt. The packet was then copied from the input port into processor memory. The routing processor then extracted the destination address from the header, looked up the appropriate output port in the forwarding table, and copied the packet to the output port’s buffers.&lt;/li&gt;
  &lt;li&gt;bus: If multiple packets arrive to the router at the same time, each at a different input port, all but one must wait since only one packet can cross the bus at a time.&lt;/li&gt;
  &lt;li&gt;interconnection network: A crossbar switch is an interconnection network consisting of 2N buses that connect N input ports to N output ports. If two packets from two different input ports are destined to the same output port, then one will have to wait at the input, since only one packet can be sent over any given bus at a time.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;output-ports&quot;&gt;Output ports&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;switch fabric -&amp;gt; queuing (buffer management) -&amp;gt; data link processing (protocol, decapsulation) -&amp;gt;line termination&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;input-port-queuing&quot;&gt;Input port queuing&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;fabric slower than input ports combined -&amp;gt; queuing may occur at input queues&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;head-of-the-Line (HOL) blocking&lt;/strong&gt;: queued datagram at front of queue prevents others in queue from moving forward&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;output-port-queuing&quot;&gt;Output Port Queuing&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;buffering when arrival rate via switch exceeds output line speed&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;buffer-design&quot;&gt;Buffer design&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;how much buffer? rule of thumb
    &lt;ul&gt;
      &lt;li&gt;RTT; round-trip time; C: link capacity; N: number of TCP flows&lt;/li&gt;
      &lt;li&gt;average buffer = RTT * C&lt;/li&gt;
      &lt;li&gt;recent recommendation: with N flows, buffer equal to $RTT * C / \sqrt{N}$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;internets-network-layer&quot;&gt;Internet’s network layer&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IP protocol&lt;/li&gt;
  &lt;li&gt;routing component: routing protocols compute the forwarding tables that are used to forward packets through the network&lt;/li&gt;
  &lt;li&gt;a facility to report errors in datagrams and respond to requests for certain network-layer information: Internet Control Message Protocol (ICMP)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datagram-format&quot;&gt;Datagram format&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/ipv4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;protocol: This field is used only when an IP datagram reaches its final destination. The value of this field indicates the specific transport-layer protocol to which the data portion of this IP datagram should be passed. A value of 6 indicates that the data portion is passed to TCP, while a value of 17 indicates that the data is passed to UDP.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;header-length&quot;&gt;Header length&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IP header: 20 bytes&lt;/li&gt;
  &lt;li&gt;TCP header: 20 bytes&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mtu&quot;&gt;MTU&lt;/h2&gt;
&lt;p&gt;The maximum amount of data that a link-layer frame can carry is called the maximum transmission unit (MTU).&lt;/p&gt;

&lt;h2 id=&quot;ip-fragmentation-and-reassembly&quot;&gt;IP fragmentation and reassembly&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Reassembling is done in end systems rather than routers.&lt;/li&gt;
  &lt;li&gt;maximum transmission unit (MTU) of link layer puts a hard limit to the size of IP datagram&lt;/li&gt;
  &lt;li&gt;the designers of IPv4 decided to put the job of datagram reassembly in the end systems rather than in network routers&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;identification, flag, fragmentation&lt;/em&gt; field in the header&lt;/li&gt;
  &lt;li&gt;in order for the destination host to be absolutely sure it has received
the last fragment of the original datagram, the last fragment has a flag bit set to 0,
whereas all the other fragments have this flag bit set to 1.&lt;/li&gt;
  &lt;li&gt;At the destination, the payload of the datagram is passed to the transport layer
only after the IP layer has fully reconstructed the original IP datagram. If one or
more of the fragments does not arrive at the destination, the incomplete datagram is
discarded and not passed to the transport layer&lt;/li&gt;
  &lt;li&gt;Example:&lt;br /&gt;
A datagram of 4,000 bytes (20 bytes of IP header plus 3,980 bytes of IP payload) arrives at a router and must be forwarded to a link with an MTU of 1,500 bytes.
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/ip-fragments.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ip-header-options&quot;&gt;IP header options&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;security: specifies how secret the datagram is.&lt;/li&gt;
  &lt;li&gt;strict source routing: gives the complete path to be followed&lt;/li&gt;
  &lt;li&gt;loose source route: gives a list of routers not to be missed&lt;/li&gt;
  &lt;li&gt;record route: makes each router append its IP address&lt;/li&gt;
  &lt;li&gt;Timestamp: makes each router append its timestamp and address&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ip-address&quot;&gt;IP address&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;32 bit identifier for interface of routers and hosts&lt;/li&gt;
  &lt;li&gt;written in dotted decimal&lt;/li&gt;
  &lt;li&gt;must be globally unique for globally access&lt;/li&gt;
  &lt;li&gt;IP requires each host and router interface to have its own IP address. Thus, an IP address is technically associated with an interface, rather than with the host or router containing that interface.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;subneting&quot;&gt;Subneting&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IP network: all computers addressed with a common identical network id
    &lt;ul&gt;
      &lt;li&gt;an IP network is a broadcasting network&lt;/li&gt;
      &lt;li&gt;multiple IP networks are interconnected by routers or 3-layer  switch (VLAN)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Problem with large IP networks:
    &lt;ul&gt;
      &lt;li&gt;different computers are administratively controlled by different entities&lt;/li&gt;
      &lt;li&gt;broadcasting storm&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;solution: dividing an IP network into two or more networks is called subnetting&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;What’s a subnet?
    &lt;ul&gt;
      &lt;li&gt;device interfaces with same subnet part of IP address&lt;/li&gt;
      &lt;li&gt;can physically reach each other without intervening routers&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;subnet mask&lt;/strong&gt;: 223.1.1.0/24, indicates that the leftmost 24 bits of the 32-bit quantity define the subnet address.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;classless-ip-addressing&quot;&gt;Classless IP Addressing&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;VLSM: variable length subnet mask&lt;/li&gt;
  &lt;li&gt;IP address = subnet id + host id&lt;/li&gt;
  &lt;li&gt;subnet mask: to indicate the subnet portion which is variable length
    &lt;ul&gt;
      &lt;li&gt;a.b.c.d/x, where x is # bits in subnet portion of address&lt;/li&gt;
      &lt;li&gt;1 for subnet id bits, 0 for host id bits (e.g. 255.255.255.0)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-internets-address-assignment-strategy-cidr-classless-interdomain-routing&quot;&gt;The Internet’s address assignment strategy: CIDR (Classless InterDomain Routing)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;problem: routing table explosion&lt;/li&gt;
  &lt;li&gt;assign class C addresses in &lt;strong&gt;contiguous blocks&lt;/strong&gt; of 256 addresses so that multiple entries in routing table can be aggregated into one (reduced)&lt;/li&gt;
  &lt;li&gt;Contiguous blocks of IP addresses with &lt;strong&gt;common prefix&lt;/strong&gt; and &lt;strong&gt;the whole range&lt;/strong&gt; of that prefix could be aggregated into one route entry.&lt;/li&gt;
  &lt;li&gt;Even if there is &lt;strong&gt;a hole&lt;/strong&gt; in the blocks of IP addresses the common prefix could still be aggregated with another &lt;strong&gt;longer prefix for the hole&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ip-broadcast-address&quot;&gt;IP broadcast address&lt;/h2&gt;
&lt;p&gt;When a host sends a datagram with destination address 255.255.255.255, the message is delivered to all hosts on the same subnet. Routers optionally forward the message into neighboring subnets as well&lt;/p&gt;

&lt;h2 id=&quot;dhcp-dynamic-host-configuration-protocol&quot;&gt;DHCP: Dynamic Host Configuration Protocol&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;For obtaining a host address&lt;/li&gt;
  &lt;li&gt;Four steps:
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;DHCP server discovery&lt;/strong&gt;: the DHCP client
creates an IP datagram containing its DHCP discover message along with the
broadcast destination IP address of 255.255.255.255 and a “this host” source IP
address of 0.0.0.0.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DHCP server offer(s)&lt;/strong&gt;: A DHCP server receiving a DHCP discover message
responds to the client with a DHCP offer message that is broadcast to all nodes
on the subnet, again using the IP broadcast address of 255.255.255.255&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DHCP request&lt;/strong&gt;: The newly arriving client will choose from among one or more
server offers and respond to its selected offer with a DHCP request message,&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DHCP ACK&lt;/strong&gt;: The server responds to the DHCP request message with a DHCP ACK message, confirming the requested parameters.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nat-network-address-translation&quot;&gt;NAT: Network Address Translation&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Motivation: hosts in LANs use private IP address and share one public IP address for internet access
    &lt;ul&gt;
      &lt;li&gt;handle public IP address shortage&lt;/li&gt;
      &lt;li&gt;can change address of devices in LAN without notifying outside world&lt;/li&gt;
      &lt;li&gt;can change ISPs without changing addresses of devices in LANs&lt;/li&gt;
      &lt;li&gt;devices inside not explicitly addressable, visible by outside world (a security plus)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;uses 16 bit port field&lt;/li&gt;
  &lt;li&gt;The NAT-enabled router does not look like a router to the outside world. Instead
the NAT router behaves to the outside world as a single device with a single IP
address.&lt;/li&gt;
  &lt;li&gt;NAT is controversial:
    &lt;ul&gt;
      &lt;li&gt;violates independence layering principles&lt;/li&gt;
      &lt;li&gt;violates end-to-end argument
        &lt;ul&gt;
          &lt;li&gt;NAT traversals must be taken into account by app designers&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;address shortage should instead be addressed by IPv6&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nat-traversal-problem&quot;&gt;NAT Traversal Problem&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Solution 1: &lt;strong&gt;statically configure NAT&lt;/strong&gt; to forward incoming connection requests at given port to server&lt;/li&gt;
  &lt;li&gt;Solution 2: Universal Plug and Play:
With UPnP, an application running in a host can request a NAT mapping between its (private IP address, private port number) and the (public IP address, public port number) for some requested public port number.
In summary, UPnP allows external hosts to initiate communication sessions to NATed hosts, using either TCP or UDP.&lt;/li&gt;
  &lt;li&gt;Solution 3: relaying (used in Skype)
    &lt;ul&gt;
      &lt;li&gt;NATed client establishes connection to relay&lt;/li&gt;
      &lt;li&gt;External client connects to relay&lt;/li&gt;
      &lt;li&gt;relay bridges packets between to connections&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;icmp&quot;&gt;ICMP&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Internet Control Message Protocol&lt;/li&gt;
  &lt;li&gt;ICMP is often considered part of IP but architecturally it lies just above IP, as ICMP messages are carried inside IP datagrams. That is, ICMP messages are carried as IP payload&lt;/li&gt;
  &lt;li&gt;Note that ICMP messages are used not only for signaling error conditions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ipv6&quot;&gt;IPv6&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;initial motivation: 32 bit address space soon to be completely allocated&lt;/li&gt;
  &lt;li&gt;additional motivation:
    &lt;ul&gt;
      &lt;li&gt;header format helps speed processing/forwarding&lt;/li&gt;
      &lt;li&gt;header changes to facilitate QoS&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IPv6 datagram format:
  &lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/ipv6.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;fixed length 40 byte header&lt;/li&gt;
      &lt;li&gt;extension header allowed&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IPv6 increases the size of the IP address from 32 to 128 bits&lt;/li&gt;
  &lt;li&gt;The resulting 40-byte fixed-length header allows faster processing of the IP datagram&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;comparison-of-ipv4-and-ipv6&quot;&gt;Comparison of IPv4 and IPv6&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IPv4: 20+ byte headers, 12 + 1 fields&lt;/li&gt;
  &lt;li&gt;IPv6: 40 byte headers, 8 fields&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;routing-algorithm-classification&quot;&gt;Routing Algorithm classification&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;global:
    &lt;ul&gt;
      &lt;li&gt;all routers have complete topology and link cost information&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;link state algorithm&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;local:
    &lt;ul&gt;
      &lt;li&gt;routers knows link costs to neighbours, exchange of info with neighbors&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;distance vector algorithm&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;static:
    &lt;ul&gt;
      &lt;li&gt;routers change slowly over time&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;dynamic:
    &lt;ul&gt;
      &lt;li&gt;routers change more quickly&lt;/li&gt;
      &lt;li&gt;periodic update&lt;/li&gt;
      &lt;li&gt;in response to network topology and link costs changes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Internet routing algorithms (such as RIP, OSPF, and
BGP) are load-insensitive, as a link’s cost does not explicitly reflect its current (or
recent past) level of congestion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;routing-algorithms&quot;&gt;Routing algorithms&lt;/h2&gt;
&lt;h2 id=&quot;link-state-routing-lsr&quot;&gt;Link state routing (LSR):&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Each router learns the entire network topology through exchanging information with all other routers, and then calculate least cost path to the other routers.&lt;/li&gt;
  &lt;li&gt;Dijkstra’s algorithm to build the sink tree
    &lt;ul&gt;
      &lt;li&gt;The number of times the loop is executed is equal to the number of nodes in the network.
  &lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/LS.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;distance-vector-routing--bellman-ford&quot;&gt;Distance Vector Routing / Bellman-Ford&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Each router maintains a table (i.e Distance Vector) with least cost/distance to every other routers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;comparison-between-lsr-and-dvr&quot;&gt;Comparison between LSR and DVR&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;message complexity:
    &lt;ul&gt;
      &lt;li&gt;LSR: with n nodes, E links, O(nE) messages sent totally, O(n^2) complexity&lt;/li&gt;
      &lt;li&gt;DVR: exchange between neighbors only, O(n) totally&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;computation complexity:
    &lt;ul&gt;
      &lt;li&gt;LSR: O(n^2) each node&lt;/li&gt;
      &lt;li&gt;DVR: O(n) each node&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;speed of convergence:
    &lt;ul&gt;
      &lt;li&gt;LSR: 1 iteration, may have oscilliations&lt;/li&gt;
      &lt;li&gt;DVR: n iterations
        &lt;ul&gt;
          &lt;li&gt;good news travel fast&lt;/li&gt;
          &lt;li&gt;count-to-infinity problem&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;updating when:
    &lt;ul&gt;
      &lt;li&gt;local link cost change&lt;/li&gt;
      &lt;li&gt;LS/DV update message from others/neighbors&lt;/li&gt;
      &lt;li&gt;periodically&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Neither algorithm is an obvious winner over the other; indeed, both algorithms are used in the Internet.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hierarchical-routing&quot;&gt;Hierarchical Routing&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Autonomous System (AS)&lt;/strong&gt;: aggregate routers into regions, correspond to an administrative domain. Assigned an unique 16/32 bit number&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;intra-AS/interior gateway routing&lt;/strong&gt; should find the least cost path as best as possible
    &lt;ul&gt;
      &lt;li&gt;routers in same AS run same routing protocol&lt;/li&gt;
      &lt;li&gt;routers in different AS can run different intra-AS routing protocol&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;inter-AS/exterior gateway routing&lt;/strong&gt; has to deal with a lot of politics. Routers do not automatically use the routes they find, but have to check manually whether it is allowed.&lt;/li&gt;
  &lt;li&gt;Why different intra-AS, inter-AS routing?
    &lt;ul&gt;
      &lt;li&gt;policy:
        &lt;ul&gt;
          &lt;li&gt;inter-AS: admins want to have control over how its traffic routed, and who routes through its net. (untrusted)&lt;/li&gt;
          &lt;li&gt;intra-AS: single admin, so no policy decisions needed (trusted)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;scale: hierarchical routing saves table size, reduced update traffic&lt;/li&gt;
      &lt;li&gt;performance:
        &lt;ul&gt;
          &lt;li&gt;intra-AS: can focus on performance&lt;/li&gt;
          &lt;li&gt;inter-AS: policy may dominate performance&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;routing-in-the-internet---hierarchical&quot;&gt;Routing in the internet - Hierarchical&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;most common intra-AS routing protocols
    &lt;ul&gt;
      &lt;li&gt;RIP: Routing Information Protocol&lt;/li&gt;
      &lt;li&gt;OSPF: Open Shortest Path First&lt;/li&gt;
      &lt;li&gt;IGRP: Interior Gateway Routining Protocol&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;most common inter-AS routing protocols
    &lt;ul&gt;
      &lt;li&gt;BGP: Border Gateway Protocol&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rip-routing-information-protocol&quot;&gt;RIP (Routing Information Protocol)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Distance Vector Algorithm&lt;/li&gt;
  &lt;li&gt;DV advertisement exchanged among neighbors every 30 sec in UDP packets&lt;/li&gt;
  &lt;li&gt;In RIP (and also in OSPF), costs are actually from source router to a &lt;strong&gt;destination
subnet&lt;/strong&gt;. RIP uses the term hop, which is &lt;strong&gt;the number of subnets&lt;/strong&gt; traversed
along the shortest path from source router to destination subnet, including the destination
subnet.&lt;/li&gt;
  &lt;li&gt;distance metric: # of hops, Limits networks to 15 hops (16 = inf to avoid count-to-infinity)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ospf-open-shortest-path-protocol&quot;&gt;OSPF (Open Shortest Path Protocol)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;“open”: the routing protocol specification is publicly available&lt;/li&gt;
  &lt;li&gt;OSPF is a link-state protocol that uses flooding of link-state information and a Dijkstra least-cost path algorithm&lt;/li&gt;
  &lt;li&gt;OSPF advertisements disseminated to entireAS&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;hierarchical OSPF&lt;/strong&gt; in large domains&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rip-and-ospf&quot;&gt;RIP and OSPF&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;OSPF and its closely related cousin, IS-IS, are typically deployed in upper-tier ISPs&lt;/li&gt;
  &lt;li&gt;RIP is deployed in lower-tier ISPs and enterprise networks&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hierarchical-ospf&quot;&gt;Hierarchical OSPF&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;An OSPF autonomous system can be configured hierarchically into areas. Each
area runs its own OSPF link-state routing algorithm, with each router in an area
broadcasting its link state to all other routers in that area.&lt;/li&gt;
  &lt;li&gt;two level hierarchy:
    &lt;ul&gt;
      &lt;li&gt;local area: run OSPF&lt;/li&gt;
      &lt;li&gt;backbone: area 0&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;four kinds routers
    &lt;ul&gt;
      &lt;li&gt;internal routers (IR)&lt;/li&gt;
      &lt;li&gt;area border routers (ABR): Within each area, one or more area border routers are responsible for routing packets outside the area&lt;/li&gt;
      &lt;li&gt;backbone routers (BaR): exactly one OSPF area in the AS is configured to be the backbone area. The primary role of the backbone area is to route traffic between the other areas in the AS&lt;/li&gt;
      &lt;li&gt;boundary routers (BoR)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;border-gateway-protocol&quot;&gt;Border Gateway Protocol&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;advertised prefix includes BGP attributes&lt;/li&gt;
  &lt;li&gt;route = prefix + AS-path + Next-hop&lt;/li&gt;
  &lt;li&gt;router may learn about multiple routes to some prefix. Router must select one from the routes.&lt;/li&gt;
  &lt;li&gt;ordered selection rules (for good instead of best route):&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;Local preferences (policy)&lt;/li&gt;
      &lt;li&gt;Shortest AS-path&lt;/li&gt;
      &lt;li&gt;Closet next hop router&lt;/li&gt;
      &lt;li&gt;Additional criteria&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;broadcast-and-multicast-routing&quot;&gt;Broadcast and multicast routing&lt;/h2&gt;
&lt;h2 id=&quot;broadcast-routing&quot;&gt;broadcast routing:&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;deliver packets from source to all other routers&lt;/li&gt;
  &lt;li&gt;source duplication is inefficient&lt;/li&gt;
  &lt;li&gt;in-network duplication can be more efficient with controlled duplicate transmission&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;flooding&lt;/strong&gt;: when node receives brdcst pckt, sends copies to all neighbors&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;controlled flooding&lt;/strong&gt;: node only brdcsts pkt if it hasn’t brdcst same packet before
    &lt;ul&gt;
      &lt;li&gt;node keeps track of pckt IDs already brdcsted&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;reverse path forwarding (RPF)&lt;/strong&gt;: only forward pckt if it arrived on shortest path between node and source&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;spanning tree: no redundant packets received by any nodes
    &lt;ul&gt;
      &lt;li&gt;nodes forward copies only along spanning tree&lt;/li&gt;
      &lt;li&gt;Pro: makes excellent use of bandwidth&lt;/li&gt;
      &lt;li&gt;Con: each router must have knowledge of some spanning tree&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;multicast-routing&quot;&gt;Multicast Routing&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;goal: find a tree (or trees) connecting routers having local mcast group members
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;source-based&lt;/strong&gt;: different tree from each sender to rcvrs&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;shared-tree&lt;/strong&gt;: same tree used by all group members&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IP multicasting uses &lt;strong&gt;class D&lt;/strong&gt; addresses&lt;/li&gt;
  &lt;li&gt;Each class D address identifies a group of hosts.&lt;/li&gt;
  &lt;li&gt;Groups are managed using &lt;strong&gt;IGMP (Internet Group Management Protocol)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;operates between a host and its directly attached router&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network-layer multicast in the Internet consists of two complementary components: IGMP and multicast routing protocols.&lt;/li&gt;
  &lt;li&gt;Intra-AS Multi-cast Routing Protocols
    &lt;ul&gt;
      &lt;li&gt;Distance-Vector Multicast Routing Protocol (DVMRP) uses an RPF algorithm with pruning&lt;/li&gt;
      &lt;li&gt;Protocol-Independent Multicast (PIM) routing protocol
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;dense mode&lt;/strong&gt; based on pruned RPF&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Sparse mode&lt;/strong&gt; based on pruned spanning tree&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Inter-AS Multi-cast Routing Protocols
    &lt;ul&gt;
      &lt;li&gt;extensions to BGP to allow it to carry routing information for other protocols, including multicast information&lt;/li&gt;
      &lt;li&gt;MSDP(Multicast Source Discovery Protocol) to connect centers in PIM sparse mode&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-5-the-data-link-layer&quot;&gt;Chapter 5 The Data Link Layer&lt;/h1&gt;

&lt;h2 id=&quot;checksum&quot;&gt;Checksum&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;In the TCP and UDP protocols, the Internet checksum is computed over all fields (header and data fields included).&lt;/li&gt;
  &lt;li&gt;In IP the checksum is computed over the IP header (since the UDP or TCP segment has its own checksum).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;data-link-layer&quot;&gt;Data link layer&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Data link layer is the place in the protocol stack where software meets hardware (firmware)&lt;/li&gt;
  &lt;li&gt;implemented in adapter (network interface card NID) in each host and routers&lt;/li&gt;
  &lt;li&gt;Data-link layer has responsibility of transferring datagram from one node to &lt;strong&gt;physically adjacent&lt;/strong&gt; node over a link (node-to-node job)&lt;/li&gt;
  &lt;li&gt;Datagram transferred by &lt;strong&gt;different link protocols&lt;/strong&gt; over multiple links from source to destination.&lt;/li&gt;
  &lt;li&gt;point-to-point link protocols
    &lt;ul&gt;
      &lt;li&gt;PPP&lt;/li&gt;
      &lt;li&gt;HDLC&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;broadcast link protocols
    &lt;ul&gt;
      &lt;li&gt;Ethernet&lt;/li&gt;
      &lt;li&gt;IEEE802.3&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;data-link-layer-services&quot;&gt;Data Link Layer Services&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;framing: encapsulate datagram into frame, adding &lt;strong&gt;header, trailer&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;reliable date transfer between adjacent nodes&lt;/li&gt;
  &lt;li&gt;link access for shared medium
    &lt;ul&gt;
      &lt;li&gt;Medium/Multiple Access Control (MAC)&lt;/li&gt;
      &lt;li&gt;“MAC” addresses: used in frame headers to identify source, destination&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;two-point-to-point-data-link-protocols&quot;&gt;Two point-to-point Data Link Protocols&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HDLC (High-Level Data Link Control):
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;bit-oriented&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;supports flow control and error control&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PPP (The Point-to-Point Protocol):
    &lt;ul&gt;
      &lt;li&gt;Internet standard (RFC1661 1662 1663), is used in the Internet for a variety of purposes, including router-to-router traffic and home user-to-ISP traffic.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;byte-oriented&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;PPP is a variant of HDLC &lt;strong&gt;without flow/error control&lt;/strong&gt;, supporting multiple upper layer protocols&lt;/li&gt;
      &lt;li&gt;PPP uses &lt;strong&gt;LCP&lt;/strong&gt; to manage links and uses &lt;strong&gt;NCP&lt;/strong&gt; to negotiate network-layer options&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ideal-mac-protocol&quot;&gt;Ideal MAC Protocol&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;for broadcast channel of rate R bps:
    &lt;ul&gt;
      &lt;li&gt;efficient: when one node wants to transmit, it can send at rate R.&lt;/li&gt;
      &lt;li&gt;fair: when M nodes want to transmit, each can send at average rate R/M&lt;/li&gt;
      &lt;li&gt;fully decentralized:
        &lt;ul&gt;
          &lt;li&gt;no special node to coordinate transmissions&lt;/li&gt;
          &lt;li&gt;no synchronization of clocks, slots&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;simple&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;three-broad-classes-of-mac-protocols&quot;&gt;Three broad classes of MAC protocols&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Channel Partitioning (static)
    &lt;ul&gt;
      &lt;li&gt;divide channel into smaller “pieces” (TDM, FDM, CDM)&lt;/li&gt;
      &lt;li&gt;allocate piece to node for &lt;strong&gt;exclusive use&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Random Access (dynamic)
    &lt;ul&gt;
      &lt;li&gt;channel not divided, allow collisions&lt;/li&gt;
      &lt;li&gt;“recover” from collisions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Taking turns (dynamic)
    &lt;ul&gt;
      &lt;li&gt;nodes take turns&lt;/li&gt;
      &lt;li&gt;nodes with more to send can take longer turns&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;random-access-mac-protocol&quot;&gt;Random Access MAC Protocol&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;random access:
    &lt;ul&gt;
      &lt;li&gt;transmit at full channel data rate R When node has packet to send&lt;/li&gt;
      &lt;li&gt;no priori coordination among nodes, possible collision&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;random access MAC protocol specifies:
    &lt;ul&gt;
      &lt;li&gt;how to detect collisions&lt;/li&gt;
      &lt;li&gt;how to recover from collisions (e.g., via delayed retransmissions)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Examples :
    &lt;ul&gt;
      &lt;li&gt;ALOHA, slotted ALOHA&lt;/li&gt;
      &lt;li&gt;CSMA, CSMA/CD, CSMA/CA&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;aloha&quot;&gt;ALOHA&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Nodes transmit immediately whenever data is ready in &lt;strong&gt;pure ALOHA&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;collision possible, retry after a random amount of time.&lt;/li&gt;
      &lt;li&gt;frame sent at t0 collides with other frames sent in [t0-1,t0+1]&lt;/li&gt;
      &lt;li&gt;Maximum efficiency of Pure ALOHA is 0.18&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Nodes transmit at the beginning of next slot whenever data is ready in &lt;strong&gt;slotted ALOHA&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Maximum efficiency of slottedALOHA is 0.36&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Problem: a node’s transmission decision is &lt;strong&gt;independent of&lt;/strong&gt; other nodes’ activities&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;csma-carrier-sense-multiple-access&quot;&gt;CSMA (Carrier Sense Multiple Access)&lt;/h2&gt;
&lt;p&gt;listen before transmit:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If channel sensed idle: transmit entire frame
    &lt;ul&gt;
      &lt;li&gt;p-persistent: transmit with probability p, and defer until next slot with probability 1-p.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;If channel sensed busy, defer transmission
    &lt;ul&gt;
      &lt;li&gt;1-persistent: keeping sensing and immediately start transmission when idle&lt;/li&gt;
      &lt;li&gt;nonpersistent: wait a random period of time before trying again&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;link-layer-addressing&quot;&gt;Link-Layer Addressing&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Each adapter in LAN has 48 bit, permanent, globally unique MAC address&lt;/li&gt;
  &lt;li&gt;MAC addresses are burned in NIC ROM&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ARP (Address Resolution Protocol)&lt;/strong&gt; is used to translate IP address into MAC address&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ethernet-efficiency&quot;&gt;Ethernet efficiency&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Ethernet (bus) efficiency is better than ALOHA, but deteriorates as bit-rate and distance raise
&lt;img src=&quot;https://lantaoyu.github.io/files/network-figures/ethernet.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Ethernet or CSMA/CD is unsuitable for high speed and long distance networks.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;collision-region-cr-and-broadcast-region-br&quot;&gt;Collision Region (CR) and Broadcast Region (BR)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Use switch to reduce the collision region&lt;/li&gt;
  &lt;li&gt;Use router to reduce the broadcasting region and connect with Internet.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;virtual-lan&quot;&gt;Virtual LAN&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Use switch to reduce the broadcasting region with less overhead and more flexibility&lt;/li&gt;
  &lt;li&gt;Multiple VLANs over single switch are different broadcast domains&lt;/li&gt;
  &lt;li&gt;VLAN can span multiple switches from different physical location&lt;/li&gt;
  &lt;li&gt;VLANs isolate broadcast domains, could only connected by routing&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-6-wireless-and-mobile-networks&quot;&gt;Chapter 6 Wireless and Mobile Networks&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;The 802.11(&lt;strong&gt;WiFi&lt;/strong&gt;) is the wireless version of 802.3 (Ethernet) , but &lt;strong&gt;much different in physical and data link layer&lt;/strong&gt;.
    &lt;ul&gt;
      &lt;li&gt;all use CSMA/CA for multiple access&lt;/li&gt;
      &lt;li&gt;all have base-station and ad-hoc network versions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;802.15: Bluetooth Architecture
    &lt;ul&gt;
      &lt;li&gt;TDD(Time Division Duplexing) : The master in each piconet defines a series of 625 μsec time slots, with the master getting half the slots and the slaves sharing the other half.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Xiaolan Gu</name><email>xiaolang@email.arizona.edu</email></author><summary type="html">Chapter 1</summary></entry><entry><title type="html">Notes for Linux Kernel</title><link href="http://localhost:4000/posts/2017/06/linux-kernels/" rel="alternate" type="text/html" title="Notes for Linux Kernel" /><published>2017-06-22T00:00:00-07:00</published><updated>2017-06-22T00:00:00-07:00</updated><id>http://localhost:4000/posts/2017/06/linux</id><content type="html" xml:base="http://localhost:4000/posts/2017/06/linux-kernels/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;h2 id=&quot;features&quot;&gt;Features&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Preemptive multitasking&lt;/li&gt;
  &lt;li&gt;Virtual memory&lt;/li&gt;
  &lt;li&gt;Shared libraries&lt;/li&gt;
  &lt;li&gt;Demand loading, dynamic kernel modules&lt;/li&gt;
  &lt;li&gt;TCP/IP networking&lt;/li&gt;
  &lt;li&gt;Symmetrical Multi-Processing support&lt;/li&gt;
  &lt;li&gt;Open source&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;two-modes-in-linux&quot;&gt;Two modes in Linux&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;User mode: application software(including different libraries)&lt;/li&gt;
  &lt;li&gt;Kernel mode: system calls, linux kernel, hardware&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;whats-a-kernel&quot;&gt;What’s a kernel&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;executive system monitor&lt;/li&gt;
  &lt;li&gt;controls and mediates access to hardware&lt;/li&gt;
  &lt;li&gt;implements and supports fundamental abstractions (processes, files, devices)&lt;/li&gt;
  &lt;li&gt;schedules/allocates system resources (memory, cpu, disk, descriptors)&lt;/li&gt;
  &lt;li&gt;security and protection&lt;/li&gt;
  &lt;li&gt;respond to user requests for service (system calls)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kernel-design-goal&quot;&gt;Kernel design goal&lt;/h2&gt;
&lt;p&gt;performance, stability, capability, security and protection, portability, extensibility&lt;/p&gt;

&lt;h2 id=&quot;linux-source-tree-directories&quot;&gt;Linux source tree (directories)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;/root : the home directory for the root user&lt;/li&gt;
  &lt;li&gt;/home : the user’s home directories along with directories for services (ftp, http…)&lt;/li&gt;
  &lt;li&gt;/bin : commands needed during booting up that may be needed by normal users&lt;/li&gt;
  &lt;li&gt;/sbin : similar to /bin. but not intended for normal users. run by Linux.&lt;/li&gt;
  &lt;li&gt;/proc : a virtual file system that exits in the kernels imagination, which is memory. not on a disk.
    &lt;ul&gt;
      &lt;li&gt;a directory with info about process number&lt;/li&gt;
      &lt;li&gt;each process has a directory below /proc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;/usr : contain all commands, libraries, man pages, games and static files for normal operations&lt;/li&gt;
  &lt;li&gt;/boot : files used bu the bootstrap loader. kernel images are often kept here.&lt;/li&gt;
  &lt;li&gt;/lib : shared libraries needed by the programs on the root file system&lt;/li&gt;
  &lt;li&gt;/modules : loadable kernel modules, especially those needed to boot the system after disasters&lt;/li&gt;
  &lt;li&gt;/dev : device files&lt;/li&gt;
  &lt;li&gt;/etc : configuration files specific to the machine&lt;/li&gt;
  &lt;li&gt;/skel : when a home directory is created, it is initialized with files from this directory&lt;/li&gt;
  &lt;li&gt;/sysconfig : files that configure the linux system for devices&lt;/li&gt;
  &lt;li&gt;/var : files that change for mail, news , printers log files, man pages, temp files&lt;/li&gt;
  &lt;li&gt;/mnt : mount points for temporary mounts by the system administrator&lt;/li&gt;
  &lt;li&gt;/tmp : temporary files. programs running after bootup should use /var/tmp&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linuxarch&quot;&gt;linux/arch&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;subdirectories for each current port&lt;/li&gt;
  &lt;li&gt;each contains &lt;strong&gt;kernel, lib, mm, boot&lt;/strong&gt; and other directories whose contents override code stubs in architecture independent code&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linuxdrivers&quot;&gt;linux/drivers&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;largest amount of code in the kernel tree&lt;/li&gt;
  &lt;li&gt;device, bus, platform and general directories&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linuxfs&quot;&gt;linux/fs&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;contains virtual file system framework (VFS) and subdirectories for actual file systems&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linuxinclude&quot;&gt;linux/include&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;include/asm-* : architecture-dependent include subdirectories&lt;/li&gt;
  &lt;li&gt;include/linux :
    &lt;ul&gt;
      &lt;li&gt;header info needed both by the kernel and user apps&lt;/li&gt;
      &lt;li&gt;usually linked to /usr/include/linux&lt;/li&gt;
      &lt;li&gt;kernel-only portions guarded by
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  #ifdef__KERNEL__
  /* kernel stuff */
  #endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;h2 id=&quot;linuxinit&quot;&gt;linux/init&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;version.c : contains the version banner that prints at boot&lt;/li&gt;
  &lt;li&gt;main.c : architecture-independent boot code (start_kernel is the main entry point)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linuxkernel&quot;&gt;linux/kernel&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;the core kernel code&lt;/li&gt;
  &lt;li&gt;sched.c : the main kernel file (scheduler, wait queues, timers, alarms, task queues)&lt;/li&gt;
  &lt;li&gt;process control : fork.c, exec.c, signal.c, exit.c etc…&lt;/li&gt;
  &lt;li&gt;kernel module support : kmod.c, ksyms.c, module.c&lt;/li&gt;
  &lt;li&gt;other operations : time.c, resource.c, dma.c, printk.c, info.c, sys.c …&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linuxlib&quot;&gt;linux/lib&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;kernel code cannot call standard C library routines&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linuxmm&quot;&gt;linux/mm&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;paging and swapping&lt;/li&gt;
  &lt;li&gt;allocation and deallocation&lt;/li&gt;
  &lt;li&gt;memory mapping&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linuxscripts&quot;&gt;linux/scripts&lt;/h2&gt;
&lt;p&gt;scripts for:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;menu-based kernel configuration&lt;/li&gt;
  &lt;li&gt;kernel patching&lt;/li&gt;
  &lt;li&gt;generating kernel documentation&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Linux is a modular, UNIX-like monolithic kernel&lt;/li&gt;
  &lt;li&gt;kernel is the heart of the OS that executes with special hardware permission (kernel mode)&lt;/li&gt;
  &lt;li&gt;“core kernel” provides framework, data structures, support for drivers, modules, subsystems&lt;/li&gt;
  &lt;li&gt;architecture dependent source subtrees live in /arch&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;booting&quot;&gt;Booting&lt;/h3&gt;

&lt;h2 id=&quot;how-computer-startup&quot;&gt;How computer startup?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;booting&lt;/strong&gt; is a bootstrapping process that starts operating systems when the user turns on a computer system&lt;/li&gt;
  &lt;li&gt;a &lt;strong&gt;boot sequence&lt;/strong&gt; is the set of operations the computer performs when it is switched on that load an operating system&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;booting-sequence&quot;&gt;Booting sequence&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Turn on&lt;/li&gt;
  &lt;li&gt;CPU jump to address of BIOS (0xFFFF0)&lt;/li&gt;
  &lt;li&gt;BIOS runs POST (Power-On Self Test)&lt;/li&gt;
  &lt;li&gt;Find bootable devices&lt;/li&gt;
  &lt;li&gt;Load and execute boot sector from MBR&lt;/li&gt;
  &lt;li&gt;Load OS&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bios-basic-inputoutput-system&quot;&gt;BIOS (Basic Input/Output System)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;BIOS refers to the software code run by a computer when first powered on&lt;/li&gt;
  &lt;li&gt;the primary function is code program embedded on a chip and controls various devices that make up the computer&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mbr-master-boot-record&quot;&gt;MBR (Master Boot Record)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://lantaoyu.github.io/files/linux-figures/MBR.JPG&quot; alt=&quot;MBR&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OS is booted from a hard disk, where MBR contains the primary boot loader&lt;/li&gt;
  &lt;li&gt;The MBR is a 512-byte sector, located in the first sector in the disk (sector 1 of cylinder 0, head 0)&lt;/li&gt;
  &lt;li&gt;After the MBR is loaded into RAM, the BIOS yields control to it&lt;/li&gt;
  &lt;li&gt;The first 446 bytes are the primary boot loader, which contains both executable code and error message&lt;/li&gt;
  &lt;li&gt;The next 64 bytes are the partition table, which contains a record for each of four partitions&lt;/li&gt;
  &lt;li&gt;The MBR ends with two bytes that are defined as the magic number (0xAA55 or 0x55AA). 
The magic number serves as a validation check of the MBR.&lt;/li&gt;
  &lt;li&gt;To see the contents of MBR, use:
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo dd if=/dev/sda of=mbr.bin bs=512 count=1
  od -xa mbr.bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;boot-loader&quot;&gt;Boot loader&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;more aptly called the kernel loader. the task at this stage is to load the linux kernel&lt;/li&gt;
  &lt;li&gt;optional, initial RAM disk&lt;/li&gt;
  &lt;li&gt;GRUB and LILO are the most popular Linux boot loader
    &lt;ul&gt;
      &lt;li&gt;GRUB: GRand Unified Bootloader
        &lt;ul&gt;
          &lt;li&gt;an operating system independent bootloader&lt;/li&gt;
          &lt;li&gt;a multiboot software packet from GNU&lt;/li&gt;
          &lt;li&gt;flexible command line interface&lt;/li&gt;
          &lt;li&gt;file system access&lt;/li&gt;
          &lt;li&gt;support multiple executable format&lt;/li&gt;
          &lt;li&gt;support diskless system&lt;/li&gt;
          &lt;li&gt;download OS from network&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;LILO: LInux LOader
        &lt;ul&gt;
          &lt;li&gt;not dependent on a specific file system&lt;/li&gt;
          &lt;li&gt;can boot from hard disk and floppy&lt;/li&gt;
          &lt;li&gt;up to 16 different images&lt;/li&gt;
          &lt;li&gt;must change LILO when kernel image file or config file is changed&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kernel-image&quot;&gt;Kernel Image&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;The kernel is the central part in most OS beacause of its task, which is the management of the system’s resources and the communication between hardware and software components.&lt;/li&gt;
  &lt;li&gt;kernel always store in memory until computer is turned off.&lt;/li&gt;
  &lt;li&gt;kernel image is not an executable kernel, but a compressed kernel image&lt;/li&gt;
  &lt;li&gt;zImage size is less than 512 KB&lt;/li&gt;
  &lt;li&gt;bzImage is larger than 512 KB&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;task-of-kernel&quot;&gt;Task of kernel&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;process management&lt;/li&gt;
  &lt;li&gt;memory management&lt;/li&gt;
  &lt;li&gt;device management&lt;/li&gt;
  &lt;li&gt;system call&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;init-process&quot;&gt;Init process&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;the first thing the kernel does is to execute init process&lt;/li&gt;
  &lt;li&gt;init is the root/parent of all processes executing in linux, and is responsible for staring all other processes&lt;/li&gt;
  &lt;li&gt;the first process that init starts is a script: /etc/rc.d/rc.sysinit&lt;/li&gt;
  &lt;li&gt;based on the appropriate run-level, scripts are executed to start various processes to run the system and make it functional&lt;/li&gt;
  &lt;li&gt;the init process id is “1”&lt;/li&gt;
  &lt;li&gt;init is responsible for starting system processes defined in /etc/inittab file&lt;/li&gt;
  &lt;li&gt;init typically will start multiple instances of “getty”, which waits for console logins which spawn one’s user shell process&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;upon shutdown, init control the sequence and processes for shutdown&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;runlevels&quot;&gt;Runlevels&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;a runlevel is a software configuration of the system which allows only a selected group of processes to exist&lt;/li&gt;
  &lt;li&gt;init can be in one of seven runlevels: 0-6&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rcd-files&quot;&gt;rc#.d files&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;rc#.d files are the scripts for a given runlevel that run during boot and shutdown&lt;/li&gt;
  &lt;li&gt;the scripts are found in /etc/rc.d/rc#.d, where the symbol # represents the run level&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;initd&quot;&gt;init.d&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;deamon is a background process&lt;/li&gt;
  &lt;li&gt;init.d is a directory that admin can start/stop individual deamons by changing on it&lt;/li&gt;
  &lt;li&gt;admin can issue the command and either the satrt, stop, status, restart or reload option&lt;/li&gt;
  &lt;li&gt;e.g. to stop the web server
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cd /etc/rc.d/init.d/
  httpd stop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实模式下的系统初始化&quot;&gt;实模式下的系统初始化&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;setup.S连同内核映象由bootsect.S装入。setup.S从BIOS获取计算机系统的参数,放到内存参数区,仍在实模式下运行&lt;/li&gt;
  &lt;li&gt;辅助程序setup为内核映象的执行做好准备,然后跳转到0x10000(小内核),0x100000(大内核)开始内核本身的执行,此后就是内核的初始化过程&lt;/li&gt;
  &lt;li&gt;setup.S:
    &lt;ul&gt;
      &lt;li&gt;版本检查和参数设置&lt;/li&gt;
      &lt;li&gt;为进入保护模式做准备&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;保护模式下的系统初始化&quot;&gt;保护模式下的系统初始化&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;初始化寄存器和数据区&lt;/li&gt;
  &lt;li&gt;核心代码解压缩：调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mics.c&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;decompress_kernel&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;页表初始化&lt;/li&gt;
  &lt;li&gt;初始化 idt, gdt, ldt&lt;/li&gt;
  &lt;li&gt;启动核心
    &lt;ul&gt;
      &lt;li&gt;前面是对CPU进行初始化，并启动保护模式&lt;/li&gt;
      &lt;li&gt;现在的任务是初始化内核的核心数据结构，主要涉及：
        &lt;ul&gt;
          &lt;li&gt;中断管理&lt;/li&gt;
          &lt;li&gt;进程管理&lt;/li&gt;
          &lt;li&gt;内存管理&lt;/li&gt;
          &lt;li&gt;设备管理&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;进入保护模式后，系统从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_kernel&lt;/code&gt;开始执行，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_kernel&lt;/code&gt;函数变成0号进程，不再返回&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Start_kernel&lt;/code&gt;显示版本信息,调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setup_arch()&lt;/code&gt;初始化核心的数据结构&lt;/li&gt;
      &lt;li&gt;最后,调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kernel_thread()&lt;/code&gt;创建1号进程&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt;进程&lt;/li&gt;
      &lt;li&gt;父进程创建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt;子进程之后,返回执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpu_idle&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Q: 在i386中,内核可执行代码在内存中的首地址是否可随意选择?&lt;br /&gt;
A: 从原理上讲是可以的,但实际上要考虑许多因素。例如微机内存的低端1MB的地址空间是不连续的。所以要把内核代码放在低端就要看是否能放的下。如果内核代码模块太大就不能将内核放在低端。&lt;/li&gt;
  &lt;li&gt;Q: 主引导扇区位于硬盘的什么位置,如果一个硬盘的主引导扇区有故障此硬盘是否还可以使用?&lt;br /&gt;
A: 主引导扇区位于硬盘的0面0道1扇区。一般来讲如果一个硬盘的主引导扇区有故障,此硬盘虽然可以使用,但不能作为引导盘使用了,因为它的主引导扇区不能读出内容。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;proc-file-system-and-kernel-module-programming&quot;&gt;/proc File System and Kernel Module Programming&lt;/h2&gt;
&lt;h2 id=&quot;what-is-a-kernel-module&quot;&gt;What is a kernel module?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;(wiki) an object file that contains code to extend the running kernel&lt;/li&gt;
  &lt;li&gt;(RedHat) modules are pieces of code that can be loaded and unloaded into the kernel upon demand
    &lt;h2 id=&quot;advantages-and-disadvantages&quot;&gt;advantages and disadvantages&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;advantages:
    &lt;ul&gt;
      &lt;li&gt;allowing the dynamic insertion and removal of code from the kernel at run-time&lt;/li&gt;
      &lt;li&gt;save memory cost&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;disadvantages: fragmentation penalty -&amp;gt; decrease memory performance&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;current-kernel-modules&quot;&gt;current kernel modules&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /lib/modules/2.6.32-22-generic/
find . -name &quot;*.ko&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;current-loaded-modules&quot;&gt;current loaded modules&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsmod&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /proc/modules&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;proc&quot;&gt;/proc&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;a pseudo file system&lt;/li&gt;
  &lt;li&gt;real time, resides in the &lt;strong&gt;virtual memory&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;tracks the processes running on the machine and the state of the system&lt;/li&gt;
  &lt;li&gt;a new /proc file system is created every time your linux machine reboots&lt;/li&gt;
  &lt;li&gt;highly dynamic. the size of the proc directory is 0 and the last time of modification is the last bootup time&lt;/li&gt;
  &lt;li&gt;/proc file system doesn’t exist on any particular media&lt;/li&gt;
  &lt;li&gt;the contents of the /proc file system can be read by anyone who has the requisite permissions&lt;/li&gt;
  &lt;li&gt;certain parts of the /proc file system can be read only by the owner of the process and of course root (some not even by root)&lt;/li&gt;
  &lt;li&gt;the contents of the /proc are used by many utilities which grab the data from the particular /proc directory and display it. e.g. top, ps, lspci, dmesg etc&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tweak-kernel-parameters&quot;&gt;Tweak kernel parameters&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;/proc/sys: making changes to this directory enables you to make real time changes to certain kernel parameters&lt;/li&gt;
  &lt;li&gt;e.g. /proc/sys/net/ipv4/ip_forward, which has value of “0”, which can be seen using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat&lt;/code&gt;. This can be changed in real time by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/code&gt;, thus allowing IP forwarding.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;details-of-some-files-in-proc&quot;&gt;Details of some files in /proc&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;buddyinfo&lt;/strong&gt;: contains the number of free areas of each order for the kernel buddy system&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;cmdline&lt;/strong&gt;: kernel command line&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;cpuinfo&lt;/strong&gt;: human-readable information about the processors&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;devices&lt;/strong&gt;: list of device drivers configured into the currently running kernel (block and character)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;dma&lt;/strong&gt;: shows which DMA channels are being used at the moment&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;execdomains&lt;/strong&gt;: related to security&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;fb&lt;/strong&gt;: frame buffer devices&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;filesystems&lt;/strong&gt;: filesystems configured/supported into/by the kernel&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;interrupts&lt;/strong&gt;: number of interrupts per IRQ on the x86 architecture&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;iomem&lt;/strong&gt;:  shows the current map of the system’s memory for its various devices&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ioports&lt;/strong&gt;: provides a list of currently registered port regions used for input or output communication with a device&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;kcore&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;this file represents the physical memory of the system and is stored in the core file format&lt;/li&gt;
      &lt;li&gt;unlike most /proc files, kcore does display a size. This value is given in bytes and is equal to the size of physical memory (RAM) used plus 4 KB.&lt;/li&gt;
      &lt;li&gt;its content are designed to be examined by a debugger, such as gdb, the GNU Debugger&lt;/li&gt;
      &lt;li&gt;only root user has the rights to view this file&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;kmsg&lt;/strong&gt;: used to hold messages generated by the kernel, which are then picked up by other programs, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;klogd&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;loadavg&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;provides a look at load average&lt;/li&gt;
      &lt;li&gt;the first three columns measure CPU utilization of the last 1, 5 and 10 minutes periods.&lt;/li&gt;
      &lt;li&gt;the fourth column shows the number of currently running processes and the total number of processes&lt;/li&gt;
      &lt;li&gt;the last column displays the last process ID used&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;locks&lt;/strong&gt;: displays the files currently locked by the kernel&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;mdstat&lt;/strong&gt;: contains the current information for multiple-disk, RAID configurations&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;meminfo&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;one of the most commonly used /proc files&lt;/li&gt;
      &lt;li&gt;it reports plenty of valuable information about the current utilization of RAM on the system&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;misc&lt;/strong&gt;: this files lists miscellaneous drivers registered on the miscellaneous major device, which is number 10&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;modules&lt;/strong&gt;: displays a list of all modules that have been loade by the system&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;mounts&lt;/strong&gt;: provides a quick list of all mounts in use by the system&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;mtrr&lt;/strong&gt;: refers to the current Memory Type Range Registers (MTRRs) in use with the system&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;partitions&lt;/strong&gt;: detailed information on the various partitions currently available to the system&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;pci&lt;/strong&gt;: full list of every PCI device on your system&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;slabinfo&lt;/strong&gt;: information about the memory usage on the slab level&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;stat&lt;/strong&gt;: keeps track of a variety of different statistics about the system since it was last restarted&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;swap&lt;/strong&gt;: measure swap space and its uilization&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;uptime&lt;/strong&gt;: contains information about how long the system has on since its last restart&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;version&lt;/strong&gt;: tells the versions of the kinux kernel and gcc, as well as the version of red hat linux installed on the system&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-numerical-named-directories&quot;&gt;The numerical named directories&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;the processed that are running at the instant a snapshot of the /proc file system was taken&lt;/li&gt;
  &lt;li&gt;the contents of all the directories are the same as these directories contain the carious parameters and status of the corresponding process&lt;/li&gt;
  &lt;li&gt;you have full access only to the processes that you have started&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-typical-process-directory&quot;&gt;A typical process directory&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;cmdline: contains the whole command line used to invoke the process. the contents of this file are the command line arguments with all the parameters (without formatting/spaces)&lt;/li&gt;
  &lt;li&gt;cwd: symbolic link to the current working directory&lt;/li&gt;
  &lt;li&gt;environ: contains all the process-specific environment variables&lt;/li&gt;
  &lt;li&gt;exe: symbolic link of the executable&lt;/li&gt;
  &lt;li&gt;maps: parts of the process’ address space mapped to a file&lt;/li&gt;
  &lt;li&gt;fd: this directory contains the list of file descriptors as opened by the particular process&lt;/li&gt;
  &lt;li&gt;root: symbolic link pointing to the directory which is the root file system for the particular process&lt;/li&gt;
  &lt;li&gt;status: information about the process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;other-subdirectories-in-proc&quot;&gt;Other subdirectories in /proc&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;/proc/self: link to the currently running process&lt;/li&gt;
  &lt;li&gt;/proc/bus:
    &lt;ul&gt;
      &lt;li&gt;contains information specific to the various buses available on the system&lt;/li&gt;
      &lt;li&gt;for ISA, PCI and USB buses, current data on each is available in /proc/bus/&amp;lt;bus type directory&amp;gt;&lt;/li&gt;
      &lt;li&gt;individual bus directories, signified with numbers, contains binary files that refer to the various devices available on that bus&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;/proc/driver: specific drivers in use by kernel&lt;/li&gt;
  &lt;li&gt;/proc/fs: specific file system, file handle, inode, dentry and quota information&lt;/li&gt;
  &lt;li&gt;/proc/ide: information abput IDE devices&lt;/li&gt;
  &lt;li&gt;/proc/irq: used to set IRQ to CPU affinity&lt;/li&gt;
  &lt;li&gt;/proc/net: networking parameters and statistics
    &lt;ul&gt;
      &lt;li&gt;arp: kernel’s ARP table. useful for connecting hardware address to an IP address on a system&lt;/li&gt;
      &lt;li&gt;dev: lists the network devices along with transmit and receive statistics&lt;/li&gt;
      &lt;li&gt;route: displays the kernel’s routing table&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;/proc/scsi: like /proc/ide, it gives info about scsi devices&lt;/li&gt;
  &lt;li&gt;/proc/sys:
    &lt;ul&gt;
      &lt;li&gt;allows you to make configuration changes to a running kernel, by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;echo&lt;/code&gt; command&lt;/li&gt;
      &lt;li&gt;any configuration changes made will disappear when the system is restarted&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;procsys-subdirectories&quot;&gt;/proc/sys subdirectories&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;/proc/sys/dev: provides parameters for particular devices on the system. e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdrom/info&lt;/code&gt;: many important CD-ROM parameters&lt;/li&gt;
  &lt;li&gt;/proc/sys/kernel:
    &lt;ul&gt;
      &lt;li&gt;acct: controls the suspension of process accounting based on the percentage of free space available on the filesystem containing the log&lt;/li&gt;
      &lt;li&gt;ctrl-alt-del: controls whether [Ctrl]-[Alt]-[Delete] will gracefully restart the computer using init (value 0) or force an immediate reboot without syncing the dirty buffers to disk (value 1).&lt;/li&gt;
      &lt;li&gt;domainname: allows you to configure the system’s domain name, such as domain.com.&lt;/li&gt;
      &lt;li&gt;hostname: allows you to configure the system’s host name, such as host.domain.com&lt;/li&gt;
      &lt;li&gt;threads-max: sets the maximum number of threads to be used in the kernel, with a default value of 4096&lt;/li&gt;
      &lt;li&gt;panic: defines the number of seconds the kernel will postpone rebooting the system when a kernel panic is experienced. By default, the value is set to 0, which disables automatic rebooting after a panic.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;/proc/sys/vm: facilitates the configuration of the Linux kernel’s virtual memory subsystem&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;advantages-and-disadvantages-of-the-proc-file-system&quot;&gt;Advantages and disadvantages of the /proc file system&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;advantages:
    &lt;ul&gt;
      &lt;li&gt;coherent, intuitive interface to the kernel&lt;/li&gt;
      &lt;li&gt;great for tweaking and collecting status info&lt;/li&gt;
      &lt;li&gt;easy to use and programming&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;disadvantages:
    &lt;ul&gt;
      &lt;li&gt;certain amount of overhead, must use fs calls, alleviated somewhat by sysctl() interface&lt;/li&gt;
      &lt;li&gt;user can possibly cause system instability&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proc-file-system-entries&quot;&gt;/proc file system entries&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;to use any of the procfs functions, you have to include the correct header file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#include &amp;lt;linux/proc_fs.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct proc_dir_entry* create_proc_entry(const char* name, mode_t mode, struct proc_dir_entry* parent);&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;this function creates a regular file with the name &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, the mode &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mode&lt;/code&gt; in the directory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;to create a file in the root of the procfs, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt; parameter&lt;/li&gt;
      &lt;li&gt;when successful, the function will return a pointer to the freshly created &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct proc_dir_entry&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo_file = create_proc_entry(&quot;foo&quot;, 0644, example_dir);&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct proc_dir_entry* proc_mkdir(const char* name, struct proc_dir_entry* parent);&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;create a directory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; in the procfs directory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct proc_dir_entry* proc_symlink(const char* name, struct proc_dir_entry* parent, const char* dest);&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;this creates a symlink in the procfs directory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt; that points from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dest&lt;/code&gt;. this translates in userland to ln -s dest name&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void remove_proc_entry(const char* name, struct proc_dir_entry* parent);&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;removes the entry &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; in the directory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt; from the procfs.&lt;/li&gt;
      &lt;li&gt;be sure to free the data entry from the struct &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proc_dir_entry&lt;/code&gt; before the function is called&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tips&quot;&gt;Tips&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;modules can only use APIs exported by kernel and other modules
    &lt;ul&gt;
      &lt;li&gt;no libcs&lt;/li&gt;
      &lt;li&gt;kernel exports some common APIs&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;modules are part of kernel
    &lt;ul&gt;
      &lt;li&gt;modules can control the whole system&lt;/li&gt;
      &lt;li&gt;as a result, can damage the whole system&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;modules basically can’t be written with C++&lt;/li&gt;
  &lt;li&gt;determine which part should be in kernel&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;process-management&quot;&gt;Process Management&lt;/h1&gt;

&lt;h2 id=&quot;processes-lightweight-processes-and-threads&quot;&gt;Processes, Lightweight Processes and Threads&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Process: an instance of a program in execution&lt;/li&gt;
  &lt;li&gt;(User) Thread: an execution flow of the process
    &lt;ul&gt;
      &lt;li&gt;Pthread (POSIX thread) library&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Lightweight process (LWP): used to offer better support for multithreaded applications
    &lt;ul&gt;
      &lt;li&gt;LWP may share resources: address space, open files…&lt;/li&gt;
      &lt;li&gt;To associate a lightweight process with each thread&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;process-descriptor&quot;&gt;Process descriptor&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_struct&lt;/code&gt; data structure:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;: process state&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt;: low-level information for the process&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mm&lt;/code&gt;: pointers to memory area descriptors&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tty&lt;/code&gt;: tty associated with the process&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs&lt;/code&gt;: current directory&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;files&lt;/code&gt;: pointers to file descriptors&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal&lt;/code&gt;: signals received&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;process-state&quot;&gt;Process state&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;TASK_RUNNING: 该状态表示进程处于可运行状态，也就是说要么正在CPU中运行，要么在runqueue队列中等待运行&lt;/li&gt;
  &lt;li&gt;TASK_INTERRUPTABLE: 该状态表示进程处于可中断的睡眠状态。该进程正处在睡眠，但是可以被任何信号唤醒。当信号将该进程唤醒后，进程会去对信号做出响应。&lt;/li&gt;
  &lt;li&gt;TASK_UNINTERRUPTABLE: 该状态表示进程处于不可中断的睡眠状态。该进程正处于睡眠，专心等待某一个事件（一般是IO事件），并且不希望被其他信号唤醒。&lt;/li&gt;
  &lt;li&gt;TASK_STOPPED&lt;/li&gt;
  &lt;li&gt;TASK_TRACED&lt;/li&gt;
  &lt;li&gt;EXIT_ZOMBIE: 该状态是该进程变为僵尸进程，即其父进程没有对该进程的结束信号进行处理&lt;/li&gt;
  &lt;li&gt;EXIT_DEAD&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;identifying-a-process&quot;&gt;Identifying a process&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;process descriptor pointers: 32 bits&lt;/li&gt;
  &lt;li&gt;process ID (PID): 16 bits (~32767 for compatibility)
    &lt;ul&gt;
      &lt;li&gt;linux associates different PID with each process or LWP&lt;/li&gt;
      &lt;li&gt;programmers expect threads in the same group to have a common PID&lt;/li&gt;
      &lt;li&gt;thread group: a collection of LWPs
        &lt;ul&gt;
          &lt;li&gt;the PID of the first LWP in the group&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tgid&lt;/code&gt; field in process descriptor: using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getpid()&lt;/code&gt; system call&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-process-list&quot;&gt;The process list&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tasks&lt;/code&gt; field in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_struct&lt;/code&gt; structure
    &lt;ul&gt;
      &lt;li&gt;type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list_head&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prev&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; fields point to the previous and the next &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_struct&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;process 0 (swapper): &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init_task&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;parenthood-relationships-among-processes&quot;&gt;Parenthood relationships among processes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;process 0 and 1: created by the kernel
    &lt;ul&gt;
      &lt;li&gt;process 1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt;: the ancestor of all processes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fields in process descriptor for parenthood
    &lt;ul&gt;
      &lt;li&gt;real_parent&lt;/li&gt;
      &lt;li&gt;parent&lt;/li&gt;
      &lt;li&gt;children&lt;/li&gt;
      &lt;li&gt;sibling&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pidhash-table-and-chained-lists&quot;&gt;Pidhash table and chained lists&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;to support the search for the process descriptor of a PID, since sequential search in the process list is inefficient&lt;/li&gt;
  &lt;li&gt;the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pid_hash&lt;/code&gt; array contains four hash tables and correspnding field in the process descriptor
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pid&lt;/code&gt;: PIDTYPE_PID&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tgid&lt;/code&gt;: PIDTYPE_TGID (thread group leader)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pgrp&lt;/code&gt;: PIDTYPE_PGID (group leader)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;session&lt;/code&gt;: PIDTYPE_SID (session leader)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;chaining is used to handle PID collisions&lt;/li&gt;
  &lt;li&gt;the size of each pidhash table is dependent on the available memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pid&quot;&gt;PID&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pids&lt;/code&gt; field of the process descriptor: the pid data structure&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nr&lt;/code&gt;: PID number&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pid_chain&lt;/code&gt;: links to the previous and the next elements in the hash chain list&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pid_list&lt;/code&gt;: head of the per-PID list (in thread group)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how-processes-are-organized&quot;&gt;How processes are organized&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;processes in TASK_STOPPED, EXIT_ZOMBIE, EXIT_DEAD: not linked in lists&lt;/li&gt;
  &lt;li&gt;processes in TASK_INTERRUPTABLE, TASK_UNINTERRUPTABLE: waiting queues&lt;/li&gt;
  &lt;li&gt;two kinds of sleeping processes:
    &lt;ul&gt;
      &lt;li&gt;exclusive process&lt;/li&gt;
      &lt;li&gt;nonexclusive process: always woken up by the kernel when the event occurs&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;process-switch-task-switch-context-switch&quot;&gt;Process switch, task switch, context switch&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;hardware context switch: a far jmp (in older Linux)&lt;/li&gt;
  &lt;li&gt;software context switch: a sequence of mov instructions
    &lt;ul&gt;
      &lt;li&gt;allows better control over the validity of data being loaded&lt;/li&gt;
      &lt;li&gt;the amount of time required is about the same&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;performing-the-process-switch&quot;&gt;Performing the process switch&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;switch the page global directory&lt;/li&gt;
  &lt;li&gt;switch the kernel mode stack and the hardware context&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;task-state-segment&quot;&gt;Task State Segment&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TSS&lt;/strong&gt;: a specific segment type in x86 architecture to store &lt;strong&gt;hardware contexts&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;creating-processes&quot;&gt;Creating processes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;in traditional UNIX, resources owned by parent process are duplicated
    &lt;ul&gt;
      &lt;li&gt;very slow and inefficient&lt;/li&gt;
      &lt;li&gt;mechanisms to solve this problem
        &lt;ul&gt;
          &lt;li&gt;Copy on Write: parent and child read the same physical page&lt;/li&gt;
          &lt;li&gt;Ligitweight process (LWP): parent and child share per-process kernel data structures&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vfork()&lt;/code&gt; system call: parent and child share the memory address space&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;clone-fork-and-vfork-system-calls&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clone()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vfork()&lt;/code&gt; system calls&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clone(fn, arg, flags, child_stack, tls, ptid, ctid)&lt;/code&gt;: creating lightweight process
    &lt;ul&gt;
      &lt;li&gt;a wrapper function in C library&lt;/li&gt;
      &lt;li&gt;Uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clone()&lt;/code&gt; system call&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vfork()&lt;/code&gt; system calls: implemented by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clone&lt;/code&gt; with different parameters&lt;/li&gt;
  &lt;li&gt;each invokes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_fork()&lt;/code&gt; function&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kernel-threads&quot;&gt;Kernel threads&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;kernel threads run only in kernel mode&lt;/li&gt;
  &lt;li&gt;they use only linear addresses greater than PAGE_OFFSET&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kernel_thread()&lt;/code&gt;: to create a kernel thread&lt;/li&gt;
  &lt;li&gt;example kernel threads:
    &lt;ul&gt;
      &lt;li&gt;process 0 (swapper process), the ancestor of all processes&lt;/li&gt;
      &lt;li&gt;process 1 (init process)&lt;/li&gt;
      &lt;li&gt;others: keventd, kapm…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;destrying-processes&quot;&gt;Destrying processes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt; library function
    &lt;ul&gt;
      &lt;li&gt;two system calls in Linux 2.6
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_exit()&lt;/code&gt; system call: handled by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_exit()&lt;/code&gt; function&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit_group()&lt;/code&gt; system call: handled by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_group_exit()&lt;/code&gt; function&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;process removal: releasing the process descriptor of a zombie process by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release_task()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scheduling-policy&quot;&gt;Scheduling policy&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;based on time-sharing:
    &lt;ul&gt;
      &lt;li&gt;time slice&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;based on priority ranking:
    &lt;ul&gt;
      &lt;li&gt;dynamic&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;classification of processes:
    &lt;ul&gt;
      &lt;li&gt;interactive processes: e.g. shells, text editors, GUI applications&lt;/li&gt;
      &lt;li&gt;batch processes: e.g. compilers, database search engine, web server&lt;/li&gt;
      &lt;li&gt;real-time processes: e.g. audio/video applications, data-collection from physical sensors, robit controllers&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;process-preemption&quot;&gt;Process preemption&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Linux (user) processes are preemptive
    &lt;ul&gt;
      &lt;li&gt;when a new process has higher priority than the current&lt;/li&gt;
      &lt;li&gt;when its time quantum expires, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIF_NEED_RESCHED&lt;/code&gt; in thread_info will be set&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;a preempted process is not suspended since it remains in the &lt;strong&gt;TASK_RUNNING&lt;/strong&gt; state&lt;/li&gt;
  &lt;li&gt;Linux kernel before 2.6 is nonpreemptive, simpler&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how-long-should-a-quantum-last&quot;&gt;How long should a quantum last&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;neither too long nor too short:
    &lt;ul&gt;
      &lt;li&gt;too short: overhead for process switch&lt;/li&gt;
      &lt;li&gt;too long: process no longer appear to be executed concurrently&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;always a compromise: the rule of thumb, to choose a duration as long as possible, while keeping good system response&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scheduling-algorithm&quot;&gt;Scheduling algorithm&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;earlier version of Linux: simple and straightforward
    &lt;ul&gt;
      &lt;li&gt;at every process switch, scan the runnable processes, compute the priorities and select the best one to run&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;much more complex in Linux 2.6
    &lt;ul&gt;
      &lt;li&gt;scales well with the number of processes and processors&lt;/li&gt;
      &lt;li&gt;constant time scheduling&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3 scheduling classes
    &lt;ul&gt;
      &lt;li&gt;SCHED_FIFO: first-in first-out real-time&lt;/li&gt;
      &lt;li&gt;SCHED_RR: round-robin real-time&lt;/li&gt;
      &lt;li&gt;SCHED_NORMAL: conventional time-shared processes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scheduling-of-conventional-processes&quot;&gt;Scheduling of conventional processes&lt;/h2&gt;
&lt;h2 id=&quot;static-priority&quot;&gt;Static priority&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;static priority
    &lt;ul&gt;
      &lt;li&gt;conventional processes: 100 - 139
        &lt;ul&gt;
          &lt;li&gt;can be changed by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nice()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setpriority()&lt;/code&gt; system calls&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;base time quantum: the time-quantum assigned by the scheduler if it has exhausted its previous time quantum &lt;br /&gt;
  &lt;img src=&quot;https://lantaoyu.github.io/files/linux-figures/base_time_quantum.png&quot; alt=&quot;base time quantum&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dynamic-priority-and-average-sleep-time&quot;&gt;Dynamic priority and average sleep time&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;dynamic priority: 100 - 139&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dynamic priority = max(100, min(static_priority - bonus + 5, 139))&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;bonus: 0 - 10
        &lt;ul&gt;
          &lt;li&gt;&amp;lt; 5: penalty&lt;/li&gt;
          &lt;li&gt;&amp;gt; 5: premium&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;dependent on the &lt;strong&gt;average sleep time&lt;/strong&gt;: average number of nanoseconds that the process spent while sleeping&lt;/li&gt;
      &lt;li&gt;the more average sleep time, the more bonus:&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;determine-the-status-of-a-process&quot;&gt;Determine the status of a process&lt;/h2&gt;
&lt;p&gt;To determine whether a process is considered to be interactive or batch&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;interactive if: dynamic_priority &amp;lt;= 3 * static_priority / 4 + 28&lt;/li&gt;
  &lt;li&gt;i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bonux - 5 &amp;gt;= static_priority / 4 - 28&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;interactive delta&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;active-and-expired-processes&quot;&gt;Active and expired processes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;active processes: runnable processes that have not exhausted their time quantum&lt;/li&gt;
  &lt;li&gt;expired processes: runnable processes that have exhausted their time quantum&lt;/li&gt;
  &lt;li&gt;periodically, the role of processes changes&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scheduling-of-real-time-processes&quot;&gt;Scheduling of real-time processes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;real-time priority: 1 - 99&lt;/li&gt;
  &lt;li&gt;real-time processes are always considered active
    &lt;ul&gt;
      &lt;li&gt;can be changed by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_setparam()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_setscheduler()&lt;/code&gt; system calls&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;a real-time process is replaced only when:
    &lt;ul&gt;
      &lt;li&gt;another process has higher real-time priority&lt;/li&gt;
      &lt;li&gt;put to sleep by blocking operation&lt;/li&gt;
      &lt;li&gt;stopped or killed&lt;/li&gt;
      &lt;li&gt;voluntarily relinquishes the CPU by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yield()&lt;/code&gt; system call&lt;/li&gt;
      &lt;li&gt;for round-robin real time (SCHED_RR), time quantum exhausted&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implementation-support-of-scheduling&quot;&gt;Implementation Support of Scheduling&lt;/h2&gt;

&lt;h2 id=&quot;data-structures-used-by-the-scheduler&quot;&gt;Data structures used by the scheduler&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runqueue&lt;/code&gt; data structure for each CPU&lt;/li&gt;
  &lt;li&gt;two sets of runnable processes in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runqueue&lt;/code&gt; structure&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prio_array_t&lt;/code&gt; data structure
    &lt;ul&gt;
      &lt;li&gt;nr_active: # of process descriptors in the list&lt;/li&gt;
      &lt;li&gt;bitmap: priority bitmap&lt;/li&gt;
      &lt;li&gt;queue: the 140 list_heads&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;functions-used-by-the-scheduler&quot;&gt;Functions used by the scheduler&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler_tick()&lt;/code&gt;: keep the time_slice counter up-to-date&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_to_wake_up()&lt;/code&gt; awaken a sleeping process&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recalc_task_prio()&lt;/code&gt;: updates the dynamic priority&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load_balance()&lt;/code&gt;: keep the runqueue of multiprocess system balanced&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;: select a new process to run
    &lt;ul&gt;
      &lt;li&gt;Direct invocation:
        &lt;ul&gt;
          &lt;li&gt;when the process must be blocked to wait for resource&lt;/li&gt;
          &lt;li&gt;when long iterative tasks are executed in device drivers&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Lazy invocation: by setting the TIF_NEED_RESCHED flag
        &lt;ul&gt;
          &lt;li&gt;when current process has used up its quantum, by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scheduler_tick()&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;when a process is woken up, by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_to_wake_up()&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;when a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_setscheduler()&lt;/code&gt; system call is issued&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;runqueue-balancing-in-multiprocessor-systems&quot;&gt;Runqueue balancing in multiprocessor systems&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;3 types of multiprocessor systems
    &lt;ul&gt;
      &lt;li&gt;Classic multiprocessor architecture&lt;/li&gt;
      &lt;li&gt;Hyper-threading&lt;/li&gt;
      &lt;li&gt;NUMA&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;A CPU can execute only the runnable processes in the corresponding runqueue&lt;/li&gt;
  &lt;li&gt;The kernel periodically checks if the workloads of the runqueues are balanced&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scheduling-domains&quot;&gt;Scheduling domains&lt;/h2&gt;
&lt;p&gt;A set of CPUs whose workloads are kept balanced by the kernel&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;hierarchically organized&lt;/li&gt;
  &lt;li&gt;partitioned into groups: a subset of CPUs&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;system-calls-related-to-scheduling&quot;&gt;System calls related to scheduling&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nice()&lt;/code&gt;: for backward compatability only
    &lt;ul&gt;
      &lt;li&gt;allow processes to change their base priority&lt;/li&gt;
      &lt;li&gt;replaced by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setpriority()&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getpriority()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setpriority()&lt;/code&gt;:
    &lt;ul&gt;
      &lt;li&gt;act on the base priorities of all processes in a given group&lt;/li&gt;
      &lt;li&gt;which: PRIO_PROCESS, PRIO_PGRP, PRIO_USER&lt;/li&gt;
      &lt;li&gt;who: the value of pid, pgrp, or uid field to be used for selecting the processes&lt;/li&gt;
      &lt;li&gt;niceval: the new base priority value: -20 - +19&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_getscheduler()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_setscheduler()&lt;/code&gt;: queries/sets the scheduling policy&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_getparam()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_setparam()&lt;/code&gt;: queries/sets the scheduling parameters&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yield()&lt;/code&gt;: to relinquish the CPU voluntarily without being suspended&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_get_priority_min()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_get_priority_max()&lt;/code&gt;: to return the minimum/maximum real-time static priority&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_rr_get_interval()&lt;/code&gt;: to write into user space the round-robin time quantum for real-time process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;completely-fair-scheduler-cfs&quot;&gt;Completely Fair Scheduler (CFS)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Motivation of CFS: running task gets 100% usage of the CPU, all other tasks get 0% usage of the CPU&lt;/li&gt;
  &lt;li&gt;New scheduling algorithm in linux kernel 2.6&lt;/li&gt;
  &lt;li&gt;Design:
    &lt;ul&gt;
      &lt;li&gt;the same &lt;strong&gt;virtual runtime&lt;/strong&gt; for each task&lt;/li&gt;
      &lt;li&gt;increasing the priority for sleeping task&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Implementation
    &lt;ul&gt;
      &lt;li&gt;stores the records about the planned tasks in a &lt;strong&gt;red-black tree&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;pick efficiently the process that has used the least amount of time (the leftmost node of the tree)&lt;/li&gt;
      &lt;li&gt;the entry of the picked process is then removed form the tree, the spent execution time is updated and the entry is then returned to the tree where it normally takes some other location.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;kernel-synchronization&quot;&gt;Kernel synchronization&lt;/h1&gt;
&lt;h2 id=&quot;kernel-control-paths&quot;&gt;Kernel control paths&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Linux kernel: like a server that answers requests
    &lt;ul&gt;
      &lt;li&gt;parts of the kernel run in an interleaved way&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kernel control path: a sequence of instructions executed in kernel mode on behalf of current process
    &lt;ul&gt;
      &lt;li&gt;interrupts and exceptions&lt;/li&gt;
      &lt;li&gt;lighter than a process (less context)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Three CPU states are considered:
    &lt;ul&gt;
      &lt;li&gt;User: running a process in user mode&lt;/li&gt;
      &lt;li&gt;Excp: running an exception or a system call handler&lt;/li&gt;
      &lt;li&gt;Intr: running an interrupt handler&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kernel-preemption&quot;&gt;Kernel preemption&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Preemptive kernel: a process running in kernel mode can be replaced by another process while in the middle of a kernel function&lt;/li&gt;
  &lt;li&gt;The  main motivation for making a kernel preemptive is to reduce the &lt;strong&gt;dispatch latency&lt;/strong&gt; of the user mode process
    &lt;ul&gt;
      &lt;li&gt;dispatch latency: delay between the time they become runnable and the time they actually begin running&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The kernel can be preempted only when it is excuting an exception handler (in particular a system call) and the kernel preemption has not been explicitly disabled&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;when-synchronization-is-necessary&quot;&gt;When synchronization is necessary&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;A &lt;strong&gt;race condition&lt;/strong&gt; can occur when the outcome of a computation depends on how two or more interleaved kernel control paths are nested&lt;/li&gt;
  &lt;li&gt;To identify and protect the &lt;strong&gt;critical regions&lt;/strong&gt; in exception handlers, interrupt handlers, deferrable functions, and kernel threads
    &lt;ul&gt;
      &lt;li&gt;On single CPU, critical region can be implemented by disabling interrupts while accessing shared data&lt;/li&gt;
      &lt;li&gt;If the same data is shared only by the service routines of system calls, critical region can be implemented by disabling kernel preemption while accessing shared data&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Things are more complicated on multiprocessor systems
    &lt;ul&gt;
      &lt;li&gt;different synchronization techniques are necessary&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;when-synchronization-is-not-necessary&quot;&gt;When synchronization is not necessary&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;The same interrupt cannot occur until the handler terminates&lt;/li&gt;
  &lt;li&gt;Interrupt handlers and softirqs are nonpreemptable, non-blocking&lt;/li&gt;
  &lt;li&gt;A kernel control path performing interrupt handling cannot be interrupted by a kernel control path executing a deferrable function or a system call service routine&lt;/li&gt;
  &lt;li&gt;Softirqs cannot be interleaved&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;per-cpu-variables&quot;&gt;Per-CPU variables&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;The simplest and most efficient synchronization technique consists of declaring kernel variables as per-cpu variables
    &lt;ul&gt;
      &lt;li&gt;an array of data structures, one element per CPU in the system&lt;/li&gt;
      &lt;li&gt;a CPU should not access the elements of the array corresponding to the other CPUs&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;While per-cpu variables provide protection against concurrent accesses from several CPUs, they do not provide protection against accesses from asynchronous functions (interrupt handles and deferrable functions)&lt;/li&gt;
  &lt;li&gt;per-cpu variables are prone to race conditions caused by kernel preemption, both in uniprocessor and multiprocessor systems&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;memory-barriers&quot;&gt;Memory Barriers&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;when dealing with synchronization, instruction reordering must be avoided&lt;/li&gt;
  &lt;li&gt;a memory barrier primitive ensures that the operations before the primitive are finished before the operations after the primitive
    &lt;ul&gt;
      &lt;li&gt;all instructions that operate on I/O ports&lt;/li&gt;
      &lt;li&gt;all instructions prefixed by lock byte&lt;/li&gt;
      &lt;li&gt;all instructions that write into control registers, system registers or debug registers&lt;/li&gt;
      &lt;li&gt;a few special instructions, e.g. iret&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spin-locks&quot;&gt;Spin locks&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Spin locks are a special kind of lock designed to work in a multiprocessor environment
    &lt;ul&gt;
      &lt;li&gt;busy waiting&lt;/li&gt;
      &lt;li&gt;very convenient&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;readwrite-spin-locks&quot;&gt;Read/Write Spin Locks&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;To increase the amount of concurrency in the kernel
    &lt;ul&gt;
      &lt;li&gt;multiple reads, one write&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rwlock_t structure
    &lt;ul&gt;
      &lt;li&gt;lock field: 32 bit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;seqlock&quot;&gt;Seqlock&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Introduced in Linux 2.6&lt;/li&gt;
  &lt;li&gt;similar to read/write spin locks&lt;/li&gt;
  &lt;li&gt;except that they give a much higher priority to writers&lt;/li&gt;
  &lt;li&gt;a writer is allowed to proceed even when readers are active&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;read-copy-update&quot;&gt;Read-Copy Update&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Read-Copy update (RCU): another synchronization technique designed to protect data structures that are mostly accessed for reading by several CPUs
    &lt;ul&gt;
      &lt;li&gt;RCU allows many readers and many writers to proceed concurrently&lt;/li&gt;
      &lt;li&gt;RCU is &lt;strong&gt;lock free&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Key ideas
    &lt;ul&gt;
      &lt;li&gt;only data structures that are dynamically allocated and referenced via pointers can be protected by RCU&lt;/li&gt;
      &lt;li&gt;No kernel control path can sleep inside a critical section protected by RCU&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;semaphores&quot;&gt;Semaphores&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;two kinds of semaphores
    &lt;ul&gt;
      &lt;li&gt;kernel semaphores: by kernel control paths&lt;/li&gt;
      &lt;li&gt;System V IPC semaphores: by user processes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kernel semaphores
    &lt;ul&gt;
      &lt;li&gt;struct semaphore
        &lt;ul&gt;
          &lt;li&gt;count&lt;/li&gt;
          &lt;li&gt;wait&lt;/li&gt;
          &lt;li&gt;sleepers&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;up()&lt;/code&gt;: to release a kernel semaphore (similar to signal)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;down()&lt;/code&gt;: to acquire kernel semaphore (similar to wait)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;readwrite-semaphores&quot;&gt;Read/Write semaphores&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;similar to read/write spin locks
    &lt;ul&gt;
      &lt;li&gt;except that waiting processes are suspended instead of spinning&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;struct rw_semaphore
    &lt;ul&gt;
      &lt;li&gt;count&lt;/li&gt;
      &lt;li&gt;wait_list&lt;/li&gt;
      &lt;li&gt;wait_lock&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init_rwsem()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;down_read()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;down_write&lt;/code&gt;: acquire a read/write semaphore&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;up_read()&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;up_write()&lt;/code&gt;: release a read/write semaphore&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;completions&quot;&gt;Completions&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;to solve a subtle race condition in multiprocessor systems
    &lt;ul&gt;
      &lt;li&gt;similar to semaphores&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;struct completion
    &lt;ul&gt;
      &lt;li&gt;done&lt;/li&gt;
      &lt;li&gt;wait&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;complete()&lt;/code&gt;: corresponding to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;up()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait_for_completion()&lt;/code&gt;: corresponding to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;down()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;local-interrupt-disabling&quot;&gt;Local interrupt disabling&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;interrupts can be disabled on a CPU with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cli&lt;/code&gt; instructions
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;local_irq_disable()&lt;/code&gt; macro&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;interrupts can enabled by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sti&lt;/code&gt; instructions
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;local_irq_enable()&lt;/code&gt; macro&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;disablingenabling-deferrable-functions&quot;&gt;Disabling/Enabling deferrable functions&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;softirq&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;the kernel sometimes need to disable deferrable functions without diabling interrupts
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;local_bh_disable()&lt;/code&gt; macro&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;local_bh_enable()&lt;/code&gt; macro&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;synchronizing-accesses-to-kernel-data-structures&quot;&gt;Synchronizing accesses to kernel data structures&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;rule of thumb for kernel developers:
    &lt;ul&gt;
      &lt;li&gt;always keep the concurrency level as high as possible in the system&lt;/li&gt;
      &lt;li&gt;two factors:
        &lt;ul&gt;
          &lt;li&gt;the number of I/O devices that operate concurrently&lt;/li&gt;
          &lt;li&gt;the number of CPUs that do productive work&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;a shared data structure consisting of a single integer value can be updated by declaring it as an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic_t&lt;/code&gt; type and by using atomic operations&lt;/li&gt;
  &lt;li&gt;inserting an element into a shared linked list is never atomic since it consists of at leasr pointer assignments&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;examples-of-race-condition&quot;&gt;Examples of race condition&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;when a program uses two or more semaphores, the potential for deadlock is present because two different paths could wait for each other&lt;/li&gt;
  &lt;li&gt;Linux has few problems with deadlocks on semaphore requests since each path usually acquire just one semaphore&lt;/li&gt;
  &lt;li&gt;in cases such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmdir()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rename()&lt;/code&gt; system calls, two semaphores requests&lt;/li&gt;
  &lt;li&gt;to avoid such deadlocks, semaphore requests are performed in address order&lt;/li&gt;
  &lt;li&gt;semaphore request are performed in predefined address order&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;symmetric-multiprocessing-smp&quot;&gt;Symmetric multiprocessing (SMP)&lt;/h1&gt;
&lt;h2 id=&quot;traditional-view&quot;&gt;Traditional View&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Traditionally, the computer has been viewed as a sequential machine
    &lt;ul&gt;
      &lt;li&gt;a processor executes instructions one at a time in sequence&lt;/li&gt;
      &lt;li&gt;each instruction is a sequence of operations&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;two popular approached to providing parallelism
    &lt;ul&gt;
      &lt;li&gt;symmetric multiprocesors&lt;/li&gt;
      &lt;li&gt;clusters&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;categories-of-computer-systems&quot;&gt;Categories of computer systems&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;single instruction single data (SISD) stream
    &lt;ul&gt;
      &lt;li&gt;single processor executes a single instruction stream to operate on data stored in a single memory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Single instruction Multiple data (SIMD) stream
    &lt;ul&gt;
      &lt;li&gt;each instruction is executed on a different set of data by the different processors&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;multiple instruction single data (MISD) stream
    &lt;ul&gt;
      &lt;li&gt;a sequence of data is transmitted to a set of processors, each execute a different instruction sequence&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;multiple instruction multiple data (MIMD)
    &lt;ul&gt;
      &lt;li&gt;a set of processors simultaneously execute different instruction sequences on different data sets&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;symmetric-multiprocessing&quot;&gt;Symmetric multiprocessing&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;kernel can execute on any processor
    &lt;ul&gt;
      &lt;li&gt;allowing portions of the kernel to execute in parallel&lt;/li&gt;
      &lt;li&gt;typically each processor does self-scheduling from the pool of available process or threads&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;smp&quot;&gt;SMP&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Symmetric multiprocessing (SMP)&lt;/strong&gt; involves a multiprocessor computer hardware and software where two or more identical processors connect to a single shared main memory, have full access to all I/O devices and are controlled by a single OS instance that treats all processors equally, reserving none for special purposes&lt;/li&gt;
  &lt;li&gt;Most multiprocessor systems today use an SMP architecture. In the case of multi-core processors, the SMP architecture applies to the cores, treating them as seperate processors&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linux-support-for-smp&quot;&gt;Linux Support for SMP&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;启动过程:BSP负责操作系统的启动,在启动的最后阶段,BSP通过IPI激活各个AP,在系统的正常运行过程中,BSP和AP基本上是无差别的&lt;/li&gt;
  &lt;li&gt;进程调度:与单处理器系统的主要差别是执行进程切换后,被换下的进程有可能会换到其他CPU上继续运行。在计算优先权时,如果进程上次运行的CPU也是当前CPU,则会适当提高优先权,这样可以更有效地利用Cache&lt;/li&gt;
  &lt;li&gt;中断系统:为了支持SMP,在硬件上需要APIC中断控制系统。Linux定义了各种IPI的中断向量以及传送IPI的函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;numa&quot;&gt;NUMA&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Non-uniform memory access (NUMA)&lt;/strong&gt; is a computer memory design used in multiprocessing, where the memory access time depends on the memory location relative to the processor&lt;/li&gt;
  &lt;li&gt;Under NUMA, a processor can access its own local memory faster than non-local memory (memory local to another processor or memeory shared between processors)&lt;/li&gt;
  &lt;li&gt;Benefits: the benefits of NUMA are limited to particular workloads, notably on servers where the data are often associated strongly with certain tasks or users&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;smp-系统启动过程&quot;&gt;SMP 系统启动过程&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;BIOS初始化：屏蔽AP(Application Processor),建立系统配置表&lt;/li&gt;
  &lt;li&gt;MBR里面的引导程序(LILO,GRUB等)将内核载入内存&lt;/li&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head.S&lt;/code&gt;中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startup_32&lt;/code&gt;函数，最后调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_kernel&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_kernel&lt;/code&gt;，这个函数相当于应用程序里面的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_kernel&lt;/code&gt; 进行一系列的初始化工作，最后将执行:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_init&lt;/code&gt;:关键的一步，启动各AP&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rest_init&lt;/code&gt;，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt; 创建1号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt; 进程，自身调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpu_idle&lt;/code&gt;成为0号进程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1号进程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt; 完成剩下的工作&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;reschedule_idle-工作过程&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reschedule_idle&lt;/code&gt; 工作过程&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;先检查p进程上一次运行的cpu是否空闲，如果空闲，这是最好的cpu，直接返回。&lt;/li&gt;
  &lt;li&gt;找一个合适的cpu，查看SMP中的每个CPU上运行的进程，与p进程相比的抢先权，把具有最高的抢先权值的进程记录在target_task中，该进程运行的cpu为最合适的CPU。&lt;/li&gt;
  &lt;li&gt;如target_task为空，说明没有找到合适的cpu，直接返回。&lt;/li&gt;
  &lt;li&gt;如果target_task不为空，则说明找到了合适的cpu，因此将target_task-&amp;gt;need_resched置为1，如果运行target_task的cpu不是当前运行的cpu，则向运行target_task的cpu发送一个IPI中断，让它重新调度。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;memory-management---addressing&quot;&gt;Memory Management - Addressing&lt;/h1&gt;
&lt;h2 id=&quot;memory-addresses&quot;&gt;Memory Addresses&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;three kinds of addresses in 80x86 microprocessors
    &lt;ul&gt;
      &lt;li&gt;logical address: included in the machine language instructions&lt;/li&gt;
      &lt;li&gt;linear address (virtual address): a single 32-bit unsigned integer that can be used to address up to 4GB&lt;/li&gt;
      &lt;li&gt;physical address (32-bit unsigned integers): used to address memory cells in memory chips&lt;/li&gt;
      &lt;li&gt;logical address =&amp;gt; &lt;strong&gt;segmentation unit&lt;/strong&gt; =&amp;gt; linear address =&amp;gt; &lt;strong&gt;paging unit&lt;/strong&gt; =&amp;gt; physical address&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;virtual-file-system-vfs&quot;&gt;Virtual File System (VFS)&lt;/h2&gt;

&lt;h2 id=&quot;role-of-vfs&quot;&gt;Role of VFS&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;a common interface to several kinds of file systems&lt;/li&gt;
  &lt;li&gt;File systems supported by the VFS
    &lt;ul&gt;
      &lt;li&gt;Disk-based filesystems&lt;/li&gt;
      &lt;li&gt;Network filesystems&lt;/li&gt;
      &lt;li&gt;special filesystems (e.g. /proc)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;common-file-system-interface&quot;&gt;Common file system interface&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;enable system calls such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; to work regardless of file system or storage media&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;file system: storage of data adhering to a specific structure&lt;/li&gt;
  &lt;li&gt;file: ordered string of bytes&lt;/li&gt;
  &lt;li&gt;directory: analogous to a folder
    &lt;ul&gt;
      &lt;li&gt;special type of file&lt;/li&gt;
      &lt;li&gt;instead of normal data, it contains &lt;strong&gt;pointers&lt;/strong&gt; to other files&lt;/li&gt;
      &lt;li&gt;directories are hooked together to create the hierarchical name space&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;metadata: information describing a file&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;physical-file-representation&quot;&gt;Physical file representation&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Inode:
    &lt;ul&gt;
      &lt;li&gt;unique index&lt;/li&gt;
      &lt;li&gt;holds file attributes and data block locations pertaining to a file&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data blocks
    &lt;ul&gt;
      &lt;li&gt;contain file data&lt;/li&gt;
      &lt;li&gt;may not be physically contiguous&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;File name:
    &lt;ul&gt;
      &lt;li&gt;human-readable identifier for each file&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-common-file-model&quot;&gt;The common file model&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;defines common file model conceptual interfaces and data structures&lt;/li&gt;
  &lt;li&gt;e.g. user space (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;) =&amp;gt; VFS (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_write()&lt;/code&gt;) =&amp;gt; file system (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file system write methods&lt;/code&gt;) =&amp;gt; physical media&lt;/li&gt;
  &lt;li&gt;object-oriented: data structures and associated operations
    &lt;ul&gt;
      &lt;li&gt;Superblock object: a mounted file system&lt;/li&gt;
      &lt;li&gt;Inode object: information about a file, represents a specific file&lt;/li&gt;
      &lt;li&gt;File object: interaction between an open file and a process&lt;/li&gt;
      &lt;li&gt;Dentry object: directory entry, single component of a path name&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vfs-operations&quot;&gt;VFS operations&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;each object contains operations object with methods:
    &lt;ul&gt;
      &lt;li&gt;super_operations: invoked on a specific file system&lt;/li&gt;
      &lt;li&gt;inode_operations: invoked on a specific inodes (which point to a file)&lt;/li&gt;
      &lt;li&gt;dentry_operations: invoked on a specific directory entry&lt;/li&gt;
      &lt;li&gt;file_operations: invoked on a file&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;lower file system can implement own version of methods to be called by VFS&lt;/li&gt;
  &lt;li&gt;if an operation is not defined by a lower file system (NULL), VFS will often call a generic version of the method&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vfs-data-structures&quot;&gt;VFS Data Structures&lt;/h2&gt;

&lt;h2 id=&quot;superblock-object&quot;&gt;Superblock object&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;implemented by each file system&lt;/li&gt;
  &lt;li&gt;used to store information describing that specific file system&lt;/li&gt;
  &lt;li&gt;often physically written at the beginning of the partition (file system control block)&lt;/li&gt;
  &lt;li&gt;found in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux/fs.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;inode-object&quot;&gt;Inode object&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;represent all the information needed to manipulate a file or directory&lt;/li&gt;
  &lt;li&gt;constructed in memory, regardless of how file system stores metadata information&lt;/li&gt;
  &lt;li&gt;three doubly linked lists
    &lt;ul&gt;
      &lt;li&gt;List of valid unused inodes&lt;/li&gt;
      &lt;li&gt;List of in-use inodes&lt;/li&gt;
      &lt;li&gt;List of dirty inodes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;power-management---from-linux-kernel-to-android&quot;&gt;Power Management - From Linux Kernel to Android&lt;/h1&gt;

&lt;h2 id=&quot;linux-power-management&quot;&gt;Linux Power Management&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Two popular power management standards in Linux
    &lt;ul&gt;
      &lt;li&gt;APM (Advanced Power Management)
        &lt;ul&gt;
          &lt;li&gt;Power management happens in two ways:
            &lt;ol&gt;
              &lt;li&gt;function calls from APM driver to the BIOS requesting power state change&lt;/li&gt;
              &lt;li&gt;automatically based on device activities&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;Power states in APM:
            &lt;ol&gt;
              &lt;li&gt;Full on&lt;/li&gt;
              &lt;li&gt;APM enabled&lt;/li&gt;
              &lt;li&gt;APM standby&lt;/li&gt;
              &lt;li&gt;APM suspend&lt;/li&gt;
              &lt;li&gt;Sleep/Hibernation&lt;/li&gt;
              &lt;li&gt;Off&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;Weakness of APM:
            &lt;ol&gt;
              &lt;li&gt;each BIOS has its own policy, different computers have different activities&lt;/li&gt;
              &lt;li&gt;unable to know why system is suspend&lt;/li&gt;
              &lt;li&gt;BIOS does not know user activities&lt;/li&gt;
              &lt;li&gt;does not know add-on devices (USB)&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ACPI (Advanced Configuration and Power Interface)
        &lt;ul&gt;
          &lt;li&gt;control divided between OS and BIOS, decisions managed through OS&lt;/li&gt;
          &lt;li&gt;Enables sophisticated power policies for general-purpose computers with standard usage patterns and hardware&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;android-power-management&quot;&gt;Android Power Management&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Built on top of Linux Power Management&lt;/li&gt;
  &lt;li&gt;Designed for devices which have a “default-off” behaviors
    &lt;ul&gt;
      &lt;li&gt;the phone is not supposed to be on when we do not want to use it&lt;/li&gt;
      &lt;li&gt;powered on only when requested to be run, off by default&lt;/li&gt;
      &lt;li&gt;unlike PC, which has a “default-on” behavior&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Apps and services must request CPU resource with
&lt;strong&gt;“wake locks”&lt;/strong&gt; through the Android application
framework (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PowerManager&lt;/code&gt; class) and native Linux libraries in order to keep
power on, otherwise Android will shut down the CPU&lt;/li&gt;
  &lt;li&gt;Android PM uses &lt;strong&gt;wake locks&lt;/strong&gt; and &lt;strong&gt;time out&lt;/strong&gt;
mechanism to switch state of system power, so that
system power consumption decreases&lt;/li&gt;
  &lt;li&gt;If there are no wake locks, CPU will be turned off&lt;/li&gt;
  &lt;li&gt;If there are &lt;strong&gt;partial wake locks&lt;/strong&gt;, screen and keyboard will be turned off&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;android-pm-state-machine&quot;&gt;Android PM State Machine&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;When an user application acquire &lt;strong&gt;full wake lock&lt;/strong&gt;
or &lt;strong&gt;screen/keyboard touch activity&lt;/strong&gt; event occur,
the machine will enter ‘AWAKE’ state&lt;/li&gt;
  &lt;li&gt;If timeout happens or power key is pressed, the machine will enter
&lt;strong&gt;“notification”&lt;/strong&gt; state:
    &lt;ul&gt;
      &lt;li&gt;if partial wake lock is acquired, the machine will remain
  “notification”&lt;/li&gt;
      &lt;li&gt;if all partial wake locks are released, the machine will
  enter &lt;strong&gt;“sleep”&lt;/strong&gt; state
  &lt;img src=&quot;https://lantaoyu.github.io/files/linux-figures/pm.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;There is one main wake lock called ‘main’ in the kernel
to keep the kernel awake
    &lt;ul&gt;
      &lt;li&gt;It is the last wake lock to be released when system goes to suspend
        &lt;h2 id=&quot;acquiring-wake-locks&quot;&gt;Acquiring wake locks&lt;/h2&gt;
        &lt;p&gt;&lt;img src=&quot;https://lantaoyu.github.io/files/linux-figures/wake_lock.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
        &lt;ol&gt;
          &lt;li&gt;request sent to PowerManager to acquire a wake lock&lt;/li&gt;
          &lt;li&gt;PowerManagementService (in the kernel) to take a wake lock&lt;/li&gt;
          &lt;li&gt;Add wake lock to the list&lt;/li&gt;
          &lt;li&gt;set the power state:&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;for a full wake lock, state should be set to “ON”
        &lt;ol&gt;
          &lt;li&gt;For taking Partial wake lock, if it is the first partial
wake lock, a kernel wake lock is taken. This will
protect all the partial wake locks. For subsequent
requests, kernel wake lock is not taken, but just
added to the list&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;system-sleep&quot;&gt;System Sleep&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://lantaoyu.github.io/files/linux-figures/sleep.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;early_suspend:
    &lt;ul&gt;
      &lt;li&gt;Used by drivers that need to handle power mode settings
  to the device before kernel is suspended&lt;/li&gt;
      &lt;li&gt;Used to turn off screen and non-wakeup source input
  devices&lt;/li&gt;
      &lt;li&gt;E.g., consider a display driver
        &lt;ul&gt;
          &lt;li&gt;In early suspend, the screen can be turned off&lt;/li&gt;
          &lt;li&gt;In the suspend, other things like closing the driver can be done&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;late_resume:
    &lt;ul&gt;
      &lt;li&gt;When system is resumed, resume is called first, followed by resume late&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;battery-service&quot;&gt;Battery Service&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;strong&gt;BatteryService&lt;/strong&gt; monitors the battery status, level, temperature etc.&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;Battery Driver&lt;/strong&gt; in the kernel interacts with the physical battery via ADC to read battery voltage and I2C&lt;/li&gt;
  &lt;li&gt;Whenever BatteryService receives information
from the BatteryDriver, it will act accordingly
    &lt;ul&gt;
      &lt;li&gt;E.g. if battery level is low, it will ask system to shutdown&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Battery Service will monitor the battery status based on received uevent from the kernel
    &lt;ul&gt;
      &lt;li&gt;uevent : An asynchronous communication channel for kernel&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Xiaolan Gu</name><email>xiaolang@email.arizona.edu</email></author><summary type="html">Introduction Features Preemptive multitasking Virtual memory Shared libraries Demand loading, dynamic kernel modules TCP/IP networking Symmetrical Multi-Processing support Open source</summary></entry><entry><title type="html">Multi-Agent Reinforcement Learning Paper Lists</title><link href="http://localhost:4000/posts/2017/06/marl-papers/" rel="alternate" type="text/html" title="Multi-Agent Reinforcement Learning Paper Lists" /><published>2017-06-05T00:00:00-07:00</published><updated>2017-06-05T00:00:00-07:00</updated><id>http://localhost:4000/posts/2017/06/marl-papers</id><content type="html" xml:base="http://localhost:4000/posts/2017/06/marl-papers/">&lt;p&gt;Multi-Agent Reinforcement Learning (MARL) is a very interesting research area, which has strong connections with single-agent RL, multi-agent systems, game theory, evolutionary computation and optimization theory.&lt;/p&gt;

&lt;p&gt;This is a collection of research and review papers of multi-agent reinforcement learning (MARL). The Papers are sorted by time. Any suggestions and pull requests are welcome.&lt;/p&gt;

&lt;p&gt;The sharing principle of these references here is for research. If any authors do not want their paper to be listed here, please feel free to contact &lt;a href=&quot;https://lantaoyu.github.io/&quot;&gt;Lantao Yu&lt;/a&gt; (Email: lantaoyu [AT] hotmail.com).&lt;/p&gt;

&lt;h2 id=&quot;tutorial-and-books&quot;&gt;Tutorial and Books&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ecmlpkdd2013.org/wp-content/uploads/2013/09/Multiagent-Reinforcement-Learning.pdf&quot;&gt;Multiagent Reinforcement Learning&lt;/a&gt; by Daan Bloembergen, Daniel Hennes, Michael Kaisers, Peter Vrancx. ECML, 2013.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.masfoundations.org/download.html&quot;&gt;Multiagent systems: Algorithmic, game-theoretic, and logical foundations&lt;/a&gt; by Shoham Y, Leyton-Brown K. Cambridge University Press, 2008.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;review-papers&quot;&gt;Review Papers&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://project-archive.inf.ed.ac.uk/msc/20162091/msc_proj.pdf&quot;&gt;Deep Reinforcement Learning Variants of Multi-Agent Learning Algorithms&lt;/a&gt; by Castaneda A O. 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jair.org/media/4818/live-4818-8818-jair.pdf&quot;&gt;Evolutionary Dynamics of Multi-Agent Learning: A Survey&lt;/a&gt; by Bloembergen, Daan, et al. JAIR, 2015.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/publication/269100101_Game_Theory_and_Multi-agent_Reinforcement_Learning&quot;&gt;Game theory and multi-agent reinforcement learning&lt;/a&gt; by Nowé A, Vrancx P, De Hauwere Y M. Reinforcement Learning. Springer Berlin Heidelberg, 2012.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.dcsc.tudelft.nl/~bdeschutter/pub/rep/10_003.pdf&quot;&gt;Multi-agent reinforcement learning: An overview&lt;/a&gt; by Buşoniu L, Babuška R, De Schutter B. Innovations in multi-agent systems and applications-1. Springer Berlin Heidelberg, 2010&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.dcsc.tudelft.nl/~bdeschutter/pub/rep/07_019.pdf&quot;&gt;A comprehensive survey of multi-agent reinforcement learning&lt;/a&gt; by Busoniu L, Babuska R, De Schutter B. IEEE Transactions on Systems Man and Cybernetics Part C Applications and Reviews, 2008&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://robotics.stanford.edu/~shoham/www%20papers/LearningInMAS.pdf&quot;&gt;If multi-agent learning is the answer, what is the question?&lt;/a&gt; by Shoham Y, Powers R, Grenager T. Artificial Intelligence, 2007.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://users.isr.ist.utl.pt/~mtjspaan/readingGroup/learningNeto05.pdf&quot;&gt;From single-agent to multi-agent reinforcement learning: Foundational concepts and methods&lt;/a&gt; by Neto G. Learning theory course, 2005.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/bb9f/bee22eae2b47bbf304804a6ac07def1aecdb.pdf&quot;&gt;Evolutionary game theory and multi-agent reinforcement learning&lt;/a&gt; by Tuyls K, Nowé A. The Knowledge Engineering Review, 2005.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/publication/221622801_An_Overview_of_Cooperative_and_Competitive_Multiagent_Learning&quot;&gt;An Overview of Cooperative and Competitive Multiagent Learning&lt;/a&gt; by Pieter Jan ’t HoenKarl TuylsLiviu PanaitSean LukeJ. A. La Poutré. AAMAS’s workshop LAMAS, 2005.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;research-papers&quot;&gt;Research Papers&lt;/h2&gt;

&lt;h3 id=&quot;framework&quot;&gt;Framework&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1706.02275.pdf&quot;&gt;Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments&lt;/a&gt; by Lowe R, Wu Y, Tamar A, et al. arXiv, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.06182.pdf&quot;&gt;Deep Decentralized Multi-task Multi-Agent RL under Partial Observability&lt;/a&gt; by Omidshafiei S, Pazis J, Amato C, et al. arXiv, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.10069.pdf&quot;&gt;Multiagent Bidirectionally-Coordinated Nets for Learning to Play StarCraft Combat Games&lt;/a&gt; by Peng P, Yuan Q, Wen Y, et al. arXiv, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.02702.pdf&quot;&gt;Robust Adversarial Reinforcement Learning&lt;/a&gt; by Lerrel Pinto, James Davidson, Rahul Sukthankar, Abhinav Gupta. arXiv, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1702.08887.pdf&quot;&gt;Stabilising Experience Replay for Deep Multi-Agent Reinforcement Learning&lt;/a&gt; by Foerster J, Nardelli N, Farquhar G, et al. arXiv, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1508.05328.pdf&quot;&gt;Multiagent reinforcement learning with sparse interactions by negotiation and knowledge transfer&lt;/a&gt; by Zhou L, Yang P, Chen C, et al. IEEE transactions on cybernetics, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1409.4561.pdf&quot;&gt;Decentralised multi-agent reinforcement learning for dynamic and uncertain environments&lt;/a&gt; by Marinescu A, Dusparic I, Taylor A, et al. arXiv, 2014.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://irll.eecs.wsu.edu/wp-content/papercite-data/pdf/2014iat-holmesparker.pdf&quot;&gt;CLEANing the reward: counterfactual actions to remove exploratory action noise in multiagent learning&lt;/a&gt; by HolmesParker C, Taylor M E, Agogino A, et al. AAMAS, 2014.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.fransoliehoek.net/docs/Amato13MSDM.pdf&quot;&gt;Bayesian reinforcement learning for multiagent systems with state uncertainty&lt;/a&gt; by Amato C, Oliehoek F A. MSDM Workshop, 2013.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.weiss-gerhard.info/publications/AI_MAGAZINE_2012_TuylsWeiss.pdf&quot;&gt;Multiagent learning: Basics, challenges, and prospects&lt;/a&gt; by Tuyls, Karl, and Gerhard Weiss. AI Magazine, 2012.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://icml2010.haifa.il.ibm.com/papers/191.pdf&quot;&gt;Classes of multiagent q-learning dynamics with epsilon-greedy exploration&lt;/a&gt; by Wunder M, Littman M L, Babes M. ICML, 2010.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.machinelearning.org/proceedings/icml2007/papers/89.pdf&quot;&gt;Conditional random fields for multi-agent reinforcement learning&lt;/a&gt; by Zhang X, Aberdeen D, Vishwanathan S V N. ICML, 2007.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ama.imag.fr/~partalas/partalasmarl.pdf&quot;&gt;Multi-agent reinforcement learning using strategies and voting&lt;/a&gt; by Partalas, Ioannis, Ioannis Feneris, and Ioannis Vlahavas. ICTAI, 2007.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/57fb/ae00e17c0d798559ebab0e8f4267e032f41d.pdf&quot;&gt;A reinforcement learning scheme for a partially-observable multi-agent game&lt;/a&gt; by Ishii S, Fujita H, Mitsutake M, et al. Machine Learning, 2005.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lib.tkk.fi/Diss/2004/isbn9512273594/article1.pdf&quot;&gt;Asymmetric multiagent reinforcement learning&lt;/a&gt; by Könönen V. Web Intelligence and Agent Systems, 2004.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=860686&quot;&gt;Adaptive policy gradient in multiagent learning&lt;/a&gt; by Banerjee B, Peng J. AAMAS, 2003.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://papers.nips.cc/paper/2171-reinforcement-learning-to-play-an-optimal-nash-equilibrium-in-team-markov-games.pdf&quot;&gt;Reinforcement learning to play an optimal Nash equilibrium in team Markov games&lt;/a&gt; by Wang X, Sandholm T. NIPS, 2002.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sts.rpi.edu/~rsun/si-mal/article3.pdf&quot;&gt;Value-function reinforcement learning in Markov game&lt;/a&gt; by Littman M L. Cognitive Systems Research, 2001.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://researchers.lille.inria.fr/~ghavamza/my_website/Publications_files/agents01.pdf&quot;&gt;Hierarchical multi-agent reinforcement learning&lt;/a&gt; by Makar, Rajbala, Sridhar Mahadevan, and Mohammad Ghavamzadeh. The fifth international conference on Autonomous agents, 2001.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;joint-action-learning&quot;&gt;Joint action learning&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.cmu.edu/~conitzer/awesomeML06.pdf&quot;&gt;AWESOME: A general multiagent learning algorithm that converges in self-play and learns a best response against stationary opponents&lt;/a&gt; by Conitzer V, Sandholm T. Machine Learning, 2007.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://papers.nips.cc/paper/2503-extending-q-learning-to-general-adaptive-multi-agent-systems.pdf&quot;&gt;Extending Q-Learning to General Adaptive Multi-Agent Systems&lt;/a&gt; by Tesauro, Gerald. NIPS, 2003.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lirmm.fr/~jq/Cours/3cycle/module/HuWellman98icml.pdf&quot;&gt;Multiagent reinforcement learning: theoretical framework and an algorithm.&lt;/a&gt; by Hu, Junling, and Michael P. Wellman. ICML, 1998.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.aaai.org/Papers/AAAI/1998/AAAI98-106.pdf&quot;&gt;The dynamics of reinforcement learning in cooperative multiagent systems&lt;/a&gt; by Claus C, Boutilier C. AAAI, 1998.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cs.duke.edu/courses/spring07/cps296.3/littman94markov.pdf&quot;&gt;Markov games as a framework for multi-agent reinforcement learning&lt;/a&gt; by Littman, Michael L. ICML, 1994.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cooperation-and-competition&quot;&gt;Cooperation and competition&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1702.03037.pdf&quot;&gt;Multi-agent Reinforcement Learning in Sequential Social Dilemmas&lt;/a&gt; by Leibo J Z, Zambaldi V, Lanctot M, et al. arXiv, 2017. [&lt;a href=&quot;https://deepmind.com/blog/understanding-agent-cooperation/&quot;&gt;Post&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.umiacs.umd.edu/~hal/docs/daume16opponent.pdf&quot;&gt;Opponent Modeling in Deep Reinforcement Learning&lt;/a&gt; by He H, Boyd-Graber J, Kwok K, et al. ICML, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1511.08779.pdf&quot;&gt;Multiagent cooperation and competition with deep reinforcement learning&lt;/a&gt; by Tampuu A, Matiisen T, Kodelja D, et al. arXiv, 2015.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.uow.edu.au/~fren/documents/EMR_2013.pdf&quot;&gt;Emotional multiagent reinforcement learning in social dilemmas&lt;/a&gt; by Yu C, Zhang M, Ren F. International Conference on Principles and Practice of Multi-Agent Systems, 2013.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jmlr.org/papers/volume9/bab08a/bab08a.pdf&quot;&gt;Multi-agent reinforcement learning in common interest and fixed sum stochastic games: An experimental study&lt;/a&gt; by Bab, Avraham, and Ronen I. Brafman. Journal of Machine Learning Research, 2008.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/5120/d9f2c738ad223e9f8f14cb3fd5612239a35c.pdf&quot;&gt;Combining policy search with planning in multi-agent cooperation&lt;/a&gt; by Ma J, Cameron S. Robot Soccer World Cup, 2008.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jmlr.org/papers/volume7/kok06a/kok06a.pdf&quot;&gt;Collaborative multiagent reinforcement learning by payoff propagation&lt;/a&gt; by Kok J R, Vlassis N. JMLR, 2006.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.335&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;Learning to cooperate in multi-agent social dilemmas&lt;/a&gt; by de Cote E M, Lazaric A, Restelli M. AAMAS, 2006.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.machinelearning.org/proceedings/icml2005/papers/021_Learning_CrandallGoodrich.pdf&quot;&gt;Learning to compete, compromise, and cooperate in repeated general-sum games&lt;/a&gt; by Crandall J W, Goodrich M A. ICML, 2005.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.machinelearning.org/proceedings/icml2004/papers/267.pdf&quot;&gt;Sparse cooperative Q-learning&lt;/a&gt; by Kok J R, Vlassis N. ICML, 2004.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;coordination&quot;&gt;Coordination&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.03121.pdf&quot;&gt;Coordinated Multi-Agent Imitation Learning&lt;/a&gt; by Le H M, Yue Y, Carr P. arXiv, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mipc.inf.ed.ac.uk/2014/papers/mipc2014_hao_etal.pdf&quot;&gt;Reinforcement social learning of coordination in networked cooperative multiagent systems&lt;/a&gt; by Hao J, Huang D, Cai Y, et al. AAAI Workshop, 2014.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.aamas-conference.org/Proceedings/aamas2013/docs/p1101.pdf&quot;&gt;Coordinating multi-agent reinforcement learning with limited communication&lt;/a&gt; by Zhang, Chongjie, and Victor Lesser. AAMAS, 2013.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ifaamas.org/Proceedings/aamas2012/papers/1B_1.pdf&quot;&gt;Coordination guided reinforcement learning&lt;/a&gt; by Lau Q P, Lee M L, Hsu W. AAMAS, 2012.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cs.toronto.edu/~cebly/Papers/bayesMARL.pdf&quot;&gt;Coordination in multiagent reinforcement learning: a Bayesian approach&lt;/a&gt; by Chalkiadakis G, Boutilier C. AAMAS, 2003.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://users.cs.duke.edu/~parr/icml02.pdf&quot;&gt;Coordinated reinforcement learning&lt;/a&gt; by Guestrin C, Lagoudakis M, Parr R. ICML, 2002.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.aaai.org/Papers/AAAI/2002/AAAI02-050.pdf&quot;&gt;Reinforcement learning of coordination in cooperative multi-agent systems&lt;/a&gt; by Kapetanakis S, Kudenko D. AAAI/IAAI, 2002.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;security&quot;&gt;Security&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.fransoliehoek.net/docs/Klima16LICMAS.pdf&quot;&gt;Markov Security Games: Learning in Spatial Security Problems&lt;/a&gt; by Klima R, Tuyls K, Oliehoek F. The Learning, Inference and Control of Multi-Agent Systems at NIPS, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7244682&quot;&gt;Cooperative Capture by Multi-Agent using Reinforcement Learning, Application for Security Patrol Systems&lt;/a&gt; by Yasuyuki S, Hirofumi O, Tadashi M, et al. Control Conference (ASCC), 2015&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www4.ncsu.edu/~hdai/infocom-2015-XH.pdf&quot;&gt;Improving learning and adaptation in security games by exploiting information asymmetry&lt;/a&gt; by He X, Dai H, Ning P. INFOCOM, 2015.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;self-play&quot;&gt;Self-Play&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1603.01121.pdf&quot;&gt;Deep reinforcement learning from self-play in imperfect-information games&lt;/a&gt; by Heinrich, Johannes, and David Silver. arXiv, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jmlr.org/proceedings/papers/v37/heinrich15.pdf&quot;&gt;Fictitious Self-Play in Extensive-Form Games&lt;/a&gt; by Heinrich, Johannes, Marc Lanctot, and David Silver. ICML, 2015.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;learning-to-communicate&quot;&gt;Learning To Communicate&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://openreview.net/pdf?id=SkaxnKEYg&quot;&gt;EMERGENCE OF LANGUAGE WITH MULTI-AGENT GAMES: LEARNING TO COMMUNICATE WITH SEQUENCES OF SYMBOLS&lt;/a&gt; by Serhii Havrylov, Ivan Titov. ICLR Workshop, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.06585.pdf&quot;&gt;Learning Cooperative Visual Dialog Agents with Deep Reinforcement Learning&lt;/a&gt; by Abhishek Das, Satwik Kottur, et al. arXiv, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.04908.pdf&quot;&gt;Emergence of Grounded Compositional Language in Multi-Agent Populations&lt;/a&gt; by Igor Mordatch, Pieter Abbeel. arXiv, 2017. [&lt;a href=&quot;https://openai.com/blog/learning-to-communicate/&quot;&gt;Post&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://repositories.lib.utexas.edu/handle/2152/45681&quot;&gt;Cooperation and communication in multiagent deep reinforcement learning&lt;/a&gt; by Hausknecht M J. 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://openreview.net/pdf?id=Hk8N3Sclg&quot;&gt;Multi-agent cooperation and the emergence of (natural) language&lt;/a&gt; by Lazaridou A, Peysakhovich A, Baroni M. arXiv, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1602.02672.pdf&quot;&gt;Learning to communicate to solve riddles with deep distributed recurrent q-networks&lt;/a&gt; by Foerster J N, Assael Y M, de Freitas N, et al. arXiv, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1605.06676.pdf&quot;&gt;Learning to communicate with deep multi-agent reinforcement learning&lt;/a&gt; by Foerster J, Assael Y M, de Freitas N, et al. NIPS, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://papers.nips.cc/paper/6398-learning-multiagent-communication-with-backpropagation.pdf&quot;&gt;Learning multiagent communication with backpropagation&lt;/a&gt; by Sukhbaatar S, Fergus R. NIPS, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://people.csail.mit.edu/lpk/papers/dars08.pdf&quot;&gt;Efficient distributed reinforcement learning through agreement&lt;/a&gt; by Varshavskaya P, Kaelbling L P, Rus D. Distributed Autonomous Robotic Systems, 2009.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;transfer-learning&quot;&gt;Transfer Learning&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ijcai.org/Proceedings/16/Papers/565.pdf&quot;&gt;Transfer Learning for Multiagent Reinforcement Learning Systems&lt;/a&gt; by da Silva, Felipe Leno, and Anna Helena Reali Costa. IJCAI, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://web.cs.umass.edu/publication/docs/2015/UM-CS-2015-004.pdf&quot;&gt;Accelerating multi-agent reinforcement learning with dynamic co-learning&lt;/a&gt; by Garant D, da Silva B C, Lesser V, et al. Technical report, 2015&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.scss.tcd.ie/~tayloral/res/papers/Taylor_ParallelTransferLearning_ICML_2013.pdf&quot;&gt;Transfer learning in multi-agent systems through parallel transfer&lt;/a&gt; by Taylor, Adam, et al. ICML, 2013.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ewrl.files.wordpress.com/2011/08/ewrl2011_submission_19.pdf&quot;&gt;Transfer learning in multi-agent reinforcement learning domains&lt;/a&gt; by Boutsioukis, Georgios, Ioannis Partalas, and Ioannis Vlahavas. European Workshop on Reinforcement Learning, 2011.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ai.vub.ac.be/~ydehauwe/publications/ICAART2011_2.pdf&quot;&gt;Transfer Learning for Multi-agent Coordination&lt;/a&gt; by Vrancx, Peter, Yann-Michaël De Hauwere, and Ann Nowé. ICAART, 2011.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;inverse-reinforcement-learning&quot;&gt;Inverse Reinforcement Learning&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://papers.nips.cc/paper/6420-cooperative-inverse-reinforcement-learning.pdf&quot;&gt;Cooperative inverse reinforcement learning&lt;/a&gt; by Hadfield-Menell D, Russell S J, Abbeel P, et al. NIPS, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1403.6822.pdf&quot;&gt;Comparison of Multi-agent and Single-agent Inverse Learning on a Simulated Soccer Example&lt;/a&gt; by Lin X, Beling P A, Cogill R. arXiv, 2014.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1403.6508.pdf&quot;&gt;Multi-agent inverse reinforcement learning for zero-sum games&lt;/a&gt; by Lin X, Beling P A, Cogill R. arXiv, 2014.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://aamas2014.lip6.fr/proceedings/aamas/p173.pdf&quot;&gt;Multi-robot inverse reinforcement learning under occlusion with interactions&lt;/a&gt; by Bogert K, Doshi P. AAMAS, 2014.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://homes.soic.indiana.edu/natarasr/Papers/mairl.pdf&quot;&gt;Multi-agent inverse reinforcement learning&lt;/a&gt; by Natarajan S, Kunapuli G, Judah K, et al. ICMLA, 2010.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;application&quot;&gt;Application&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1702.05573.pdf&quot;&gt;Collaborative Deep Reinforcement Learning for Joint Object Search&lt;/a&gt; by Kong X, Xin B, Wang Y, et al. arXiv, 2017.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1610.03295.pdf&quot;&gt;Safe, Multi-Agent, Reinforcement Learning for Autonomous Driving&lt;/a&gt; by Shalev-Shwartz S, Shammah S, Shashua A. arXiv, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/profile/Karl_Mason/publication/299416955_Applying_Multi-Agent_Reinforcement_Learning_to_Watershed_Management/links/56f545b908ae95e8b6d1d3ff.pdf&quot;&gt;Applying multi-agent reinforcement learning to watershed management&lt;/a&gt; by Mason, Karl, et al. Proceedings of the Adaptive and Learning Agents workshop at AAMAS, 2016.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.aaai.org/ocs/index.php/AIIDE/AIIDE10/paper/viewFile/2112/2550&quot;&gt;Crowd Simulation Via Multi-Agent Reinforcement Learning&lt;/a&gt; by Torrey L. AAAI, 2010.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/61bc/b98b7ae3df894f4f72aba3d145bd48ca2cd5.pdf&quot;&gt;Traffic light control by multiagent reinforcement learning systems&lt;/a&gt; by Bakker, Bram, et al. Interactive Collaborative Information Systems, 2010.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://staff.science.uva.nl/s.a.whiteson/pubs/kuyerecml08.pdf&quot;&gt;Multiagent reinforcement learning for urban traffic control using coordination graphs&lt;/a&gt; by Kuyer, Lior, et al. oint European Conference on Machine Learning and Knowledge Discovery in Databases, 2008.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/publication/221465347_A_Multi-agent_Q-learning_Framework_for_Optimizing_Stock_Trading_Systems&quot;&gt;A multi-agent Q-learning framework for optimizing stock trading systems&lt;/a&gt; by Lee J W, Jangmin O. DEXA, 2002.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=422747CB9AF552CF1C4E455220E3F96F?doi=10.1.1.32.9887&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;Multi-agent reinforcement learning for traffic light control&lt;/a&gt; by Wiering, Marco. ICML. 2000.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Xiaolan Gu</name><email>xiaolang@email.arizona.edu</email></author><summary type="html">Multi-Agent Reinforcement Learning (MARL) is a very interesting research area, which has strong connections with single-agent RL, multi-agent systems, game theory, evolutionary computation and optimization theory.</summary></entry></feed>